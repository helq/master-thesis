\chapter{Python Static Analysis based on Abstract Interpretation}%
\label{appendix-ai-theory}

This chapter is divided into two parts: first, I present a reduced set
of Python syntax together with a (partial) formal definition of Python
semantics, and later, I show the use of the formal semantic definition
to define the abstract interpretation solution I implemented.

This chapter is meant to explain the theory behind the Abstract
Interpreter implemented. In the next chapter an explanation of the
implementation details is given\footnote{Opposed to how it looks like,
  the implementation came first. The formalisation has only been written
  specifically for this work.}.

\section{Python (reduced) syntax and semantics}%
\label{python-reduced-syntax-and-semantics}

Python has no official formal semantics. The Python Software Foundation
defines a Reference Manual for the language
\autocite{python_software_foundation_python_2019}, but they are explicit
that the manual does not define a full specification for the language.
Quote: \enquote{\ldots{} if you were coming from Mars and tried to
re-implement Python from this document alone, you might have to guess
things and in fact you would probably end up implementing quite a
different language.}

There have been a couple of formal specifications defined for Python
\autocites{politz_python_2013}{fromherz_static_2018}{guth_formal_2013}{ranson_semantics_2008}.
In this work we will define yet one more set of formal semantics for
Python. I{\todo{ok, I really have no idea if everything should be
written in third or first person, and if it can be written in both, when
should the shift occur}} decided to define my own subset of Python
because of my specific needs, some formalisations had more than what I
needed and other lacked some aspect that I wanted.

I got to admit that my formalisation resembles the most that of
\textcite{fromherz_static_2018}. In fact my formalisation is loosely
based on \textcite{fromherz_static_2018} althought the semantics of both
are quiet different. As in \textcite{fromherz_static_2018}, we define
each expression and statement step as a function from states of the
program to states of the program, but opposed to them I do not include
exception handling and breaking statements. My formalisation allows
every single value in the language to be an object: functions,
attributes, subscripts, and primitive values are all objects just as in
regular Python. The following is valid in Python and in this
formalisation:

\begin{pythoncode}
a = []
b = a.append
b(3)
a.append(2.0)
print(a)  # prints: [3, 2.0]
\end{pythoncode}

In this sense, my formalisation is closer to that of
\textcite{politz_python_2013}, where they also show how their
formalisation is able to handle similarly complex examples.

\subsection{(Reduced) Syntax}\label{reduced-syntax}

A simplified version of Python's Syntax. Modified from AST's syntax
below.

{\inlinetodo{Translate into LaTeX equations}}

\begin{verbatim}
mod = stmt*  -- A program. Starting point

expr = Int(i) for i \in \N | Float(j) for j \in floats
     | True | False | None

     | identifier         -- variable name

     | expr op expr       -- eg, a + 5
     | expr cmpop expr    -- eg, a < 5
     | expr(expr*)        -- Function calling

     | expr.identifier    -- Attribute access
     | expr[expr]         -- Not supported for Numpy Arrays :S
     | [expr*]            -- list
     | (expr*)            -- tuple

stmt = del expr           -- delete expression
      | expr = expr       -- assignment
      | expr op= expr     -- augmented assignment
      | expr: expr = expr -- type annotation
      | while expr: stmt+
      | if expr: stmt+
      | import alias+
      | from identifier import alias+
      | expr              -- An expression can be an statement

op = + | - | * | / | % | ** | << | >> | //
cmpop = < | <= | > | >=

alias = identifier | identifier as identifier

identifier = string  -- with some restrictions
\end{verbatim}

The syntax above is a subset of the Python 3.6 syntax. CPython does not
directly interpret code written in the syntax above. The usual steps of
lexing and parsing into a more explicit representation are necessary. We
will define the semantics of the language over a reduced parser syntax
and not the syntax defined above, as it eases the semantic definition of
the language. \footnote{Modified from the Python 3.6 syntax found at
  https://github.com/python/typed\_ast/blob/89242344f18f94dc109823c0732325033264e22b/ast3/Parser/Python.asdl}

\begin{verbatim}
mod = Module(stmt* body)

expr = Int(n)
     | Float(n) | True | False | None
     | Name(identifier, expr_context)
     | BinOp(operator, expr, expr)
     | Compare(expr, cmpop, expr)
     | Call(expr, expr*)
     | Attribute(expr, identifier)
     -- No need for expr_context because no user made objects are allowed yet, thus
     -- modifying attributes is not necessary
     -- | Attribute(expr, identifier, expr_context)
     | Subscript(expr, expr, expr_context)  -- No arbitrary slice allowed yet
     | List(expr*)
     | Tuple(expr*) -- No expr_context for Tuple as `(a, b) = 1, 2` is not supported

stmt = Delete(expr+)
      | Assign(expr, expr)                -- a = 3
      | AugAssign(expr, operator, expr)   -- a += 3
      | AnnAssign(expr, expr, expr)       -- a: int = 3

      | While(expr, stmt+)
      | If(expr, stmt+, stmt*)

      | Import(alias+ names)
      | ImportFrom(identifier, alias+)

      | Expr(expr)

-- Indicates why are we looking up a variable, attribute or subscript
expr_context = Load | Store | Del

operator = Add | Sub | Mult | Div | Mod | Pow | LShift
             | RShift | FloorDiv

cmpop = Lt | LtE | Gt | GtE

-- import name with optional 'as' alias.
alias = (identifier, identifier?)
\end{verbatim}

Code written in our subset of Python gets translated into this
\enquote{AST} representation, over which we define the semantics of the
language. We will no describe the process of translation as it is a very
well studied subject (parsing), but will explore some important examples
to show why the translation aids into the definition of the formal
semantics of the language:

\begin{itemize}
\item
  \pycode|a + b| gets translated into
  \pycode|BinOp(Add, Name(a, Load), Name(b, Load))|. Notice the
  \pycode|Load| context, it indicates that we want to get the value of
  the variable not a reference to it (if we wanted to alter it).
\item
  \pycode|a = 3| gets translated into
  \pycode|Assign(Name(a, Store), Int(3))|. Notice the \pycode|Store|
  context, it tells us that we will get a reference to where the value
  is stored and not its value.
\item
  \pycode|del a| gets translated into \pycode|Delete(Name(a, Del))|.
  Notice the \pycode|Del| context, it tells us that we will get the
  object where it was called from as well as it possition in the heap.
\item
  \pycode|a.b[3] + b.c| gets translated into

\begin{verbatim}
BinOp(Add,
  Subscript(Attribute(Name(a, Load), b), Int(3), Load),
  Attribute(Name(b, Load), c)
)
\end{verbatim}
\item
  \pycode|a.b[3] = 3| gets translated into

\begin{verbatim}
Assign(
  Subscript(Attribute(Name(a, Load), b), Int(3), Store),
  Int(3)
)
\end{verbatim}

  Notice how we only get the \pycode|Store| context for the subscript
  and not for anything else, as we only want to know where the value of
  the subscript is stored and nothing else.
\item
  \pycode|del a.b[3]| gets translated into

\begin{verbatim}
Delete(
  Subscript(Attribute(Name(a, Load), b), Int(3), Del)
)
\end{verbatim}

  Notice how we only get the \pycode|Del| context for the subscript and
  not for anything eles, as we only want where and whom belongs to the
  subscript and nothing else.
\end{itemize}

We will see in a moment, but the semantics of a \pycode|del| require us
to know where the identifier or attribute is located (in an object or
the store). Assigning a variable require us to know where to put a
variable. Accessing to innexistant attribute
(\pycode|class A(): ...; a = A(); a.length # error: attribute unknown|)
it's not the same as to defining a new attribute
(\pycode|class A(): ...; a = A(); a.length = 3 # works!|),
thus we need a way to distinguish between this three different
stament-dependent expressions.

{\inlinetodo{damn, this needs a rewrite :S}}

As you may have noticed already, my subset of Python does not have the
ability to allow the definition of custom functions or classes. Despite
the unability to define a custom function or class in the language, we
want to be able to call a function and access to objects attributes. We
have found that even though the amount of characteristics we support
right now is small, we are able to capture some common errors caused
when coding (e.g.~\pycode|5 \% 0| fails and we can capture it).

\subsection{Python (reduced) small step semantics}
\label{python-reduced-small-step-semantics}

There are two types of values (objects):

\begin{itemize}
\tightlist
\item
  Primitive values (\pycode|PrimVal|): integers (\pycode|int|s),
  Floating point numbers (\pycode|float|s), Boolean values
  (\pycode|True| and \pycode|False|), and the lonely \pycode|None|
  value.
\item
  Mutable values: \pycode|Object|. An \pycode|Object| is a value that
  holds a type, an address to where is located, and a
  \enquote{dictionary} pointing to other values.
\end{itemize}

Lists, Tuples, builtin Functions, builtin Modules, builtin Classes, and
builtin Methods derive from \pycode|Object|. Mutable Values may not
allow to change the value of their attributes, as in the case with
Tuples, the name \enquote{Mutable Values} refers to their ability to
point at other values (either Primitive and Mutable) and possibly change
them.

The \textbf{state of a Python program}, called the store of the program,
is a tuple \pycode|(G, Heap)| where \pycode|G| is the \enquote{global
scope} of variables, and \pycode|Heap| the heap (where all values are
stored). Notice that we are ignoring the statements to execute in the
state of the program.

Putting all together we get:

\begin{verbatim}
Global = Iden -> Addr + Undefined -- Global scope
Heap = Addr -> Val + Undefined   -- Heap

Key = Iden + (string x (Iden + PrimVal))
Type = List | Tuple | Module

PrimVal = Int | Float | True | False | None | Undefined
Object = Type x Addr x (Key -> Addr + Undefined)
Val = PrimVal | Object | <prim-callable>

<prim-callable> = <prim-append> | <prim-+-int> | <prim-+-float> | <prim-*-int> | ...
\end{verbatim}

A \pycode|<prim-callable>| is a value that is
builtin function in Python. The special value \pycode|Undefined| is used
to signal unassigned values in \pycode|Heap|. If one tries to operate
with an \pycode|Undefined| value the execution should halt, operating
with \pycode|Undefined| values is forbidden as they never appear on
Python (In Python, an \pycode|Undefined| value is an errorneous memory
value, or an unassigned region of memory).

An \pycode|Iden| is a Python identifier. A Python identifier is a string
that can only contain letters, numbers, and the character \pycode|_|.
An identifier cannot start with a number\footnote{I am simplifying here
  for the sake of brevity. In fact Python 3 does allow a wide array of
  Unicode characters to construct an identifier.
  https://docs.python.org/3/reference/lexical\_analysis.html\#identifiers}.

Notice how the index (\pycode|Key|) for the function that relates an
\pycode|Object| to its attributes can be one of two things. \pycode|Key|
is either an \pycode|Iden| or a tuple \pycode|string x PrimVal|. The
idea behind indexing an object with two separate kinds of keys is to be
able to diffirenciate between a value that is inherit to the
\pycode|Object| and other that the object simply points. Consider a
list, an inherit, unmodifiable, value of a list is its size. The size of
a list can only be modified if an element is added or removed from it.
Now, consider the value at the index 2 of the list
\pycode|[2, 54, [True], 6, 0.0]|, the value is another
\pycode|Object|. Any object stored in a list is not an intrisic property
of the list.

A \pycode|Key| can be a tuple \pycode|string x PrimVal|. There are
only two types of tuples in the current formalisation, either
\pycode|('index', val)| or
\pycode|('attr', val)|. A key of the
form \pycode|('attr', val)| indicates
us that \pycode|val| (hopefully an \pycode|Iden|) is an attribute of the
object. \pycode|('index', val)| is
used for lists.

For example, the list \pycode|[None, 4, ()]| can be expressed as:

\begin{verbatim}
(List,
 0,
 { 'size': 1,
   ('index', 0): 2,
   ('index', 1): 3,
   ('index', 2): 4
 }
),
\end{verbatim}

The first element of the triple is \pycode|List|, indicating us that the
\pycode|Object| is a list. The second element is the address on the
heap, a natural number. The third element is a function from
\pycode|Key| values to \pycode|Val|s. Strictly speaking an
\pycode|Object| cannot be defined isolated, it requires to be defined as
part of a \pycode|Heap|:

\begin{verbatim}
H = {
  0: (List, 0, { 'size': 1, ('index', 0): 2, ('index', 1): 3, ('index', 2): 4}),
  1: 3,
  2: None,
  3: 4,
  4: (Tuple, 4, {'size': 5}),
  5: 0
}
\end{verbatim}

\textbf{Notation:} A function is defined as a Python Dictionary. It is
slightly easier to type and understand \pycode|{x: m, y: n}| than
\(x \rightarrow m; y \rightarrow n\).

{\nonsection{Semantics of Expressions}}

In the same manner as \textcite{fromherz_static_2018}, we define the
semantics of an \pycode|E[expr]| as a function that
takes a state and returns a state plus a value.

An expression takes as inputs: * A Global Scope, and * A Heap

and the result of executing an expression is:

\begin{itemize}
\tightlist
\item
  A new Global Scope,
\item
  A new Heap, and
\item
  One of three things: A \pycode|Val|, an \pycode|Addr| or
  \pycode|(Object+None)xIden| if the context was \pycode|Load|,
  \pycode|Store| or \pycode|Del|, respectively.
\end{itemize}

{\inlinetodo{check all equations, especially E{[}Call(\ldots{}){]}}}

\begin{verbatim}
E[expr] :: Global x Heap
        -> Global
         x Heap
         x (Val + Addr + (Object x (string x Val)) + Iden)

E[Name(id, ctx)](G, H) :=
  match ctx in
    case Load  -> if G(id) = Undefined
                  -- if a variable is not in the global scope we check if it is builtin
                  then if isbuiltin(id)
                       then (G, H, <builtin-val>(id))
                       else <Execution Halt>
                  else (G, H, G[id])
    case Store -> (G, H, id)  -- Something will be stored in id S[Assign(...)] or variation will take care of it
    case Del   -> (G, H, id)  -- The id will be deleted, S[Delete(...)] will take care of it

E[BinOp(op, a, b)](G, H) :=
  let (G1, H1, v1) := E[a](G, H)
      (G2, H2, v2) := E[b](G1, H1)
   in if kind(v1) /= Val  or  kind(v1) /= Val
      -- Bad parsing! `E[a](G, H)` is supposed to return Val
      then <Execution Halt>
      else
        let prim_op := get_prim_op(op, type(v1), type(v2))
         in prim_op(v1, v2, G2, H2)

E[Attribute(e, attr)](G, H) :=
 let  (G1, H1, ad) := E[e](G, H)
      -- `e` must compute to a Val, we don't need Addr's or an Iden to delete
      v  := if not is_value(ad) then <Execution Halt> else ad
 in match v in
      case v: PrimVal ->
        -- primitive, similar how get_prim_op is coded
        get_prim_attr(type(v), atr)(G1, H1, v)

      case (t, addr, o): Object ->
        -- ALL values in the current definition are builtin
        if builtin(t)
        then get_prim_attr(t, attr)(G1, H1, v)

        -- Accessing (non builtin) value's attributes never happens.
        -- This code is left to show how we plan to expand the current
        -- system to support attribute access for custom objects
        else let  addr := o('attr', attr)
              in  if addr = Undefined
                  then <Execution Halt>
                  else (G1, H1, H1(addr))

      case <prim-callable> ->
        (G1, H1, v)


E[Subscript(e, i, ctx)](G, H) :=
 let  (G1, H1, ad) := E[e](G, H)
      v  := if not is_value(ad) then <Execution Halt> else ad
      (G2, H2, ind) := E[i](G1, H1)
  in
     match ctx in
       -- A Subscript with Load always returns a Val
       case Load ->
         match kind(v) in
           case (_, _, o): Object ->
             let  addr := o('index', ind)
              in  if addr = Undefined
                  then <Execution Halt>
                  else (G2, H2, H2(addr))

           otherwise -> <Execution Halt> -- No PrimVal or <prim-callable> is subscriptable

       -- A Subscript with Store always returns a (Object x (string x PrimVal))
       case Store ->
         match v in
           -- There is one check left to do, ind should be a prim val
           case Object  -> (G2, H2, (v, ('index', ind)))
           otherwise -> <Execution Halt>

       case Del ->
         if kind(v) = Object
         then (G1, H1, (v, ('index', ind)))
         else <Execution Halt>


E[List(lst)](G, H) :=
  let freeaddr := get_free_addr(H)
      empty_lst_fun('size') := length(lst)
      empty_lst_fun('index', n) :=
        if n < length(lst)
        then lst[n]  -- abusing notation, taking the `n` value from the list
        else Undefined
      lst := (List, freeaddr, empty_lst_fun) -- An object is a tuple
   in (G, H[freeaddr->lst], lst)

E[Call(caller, vals)](G, H) :=
  match E[caller](G, H) in
    -- Abusing notation by magically unfolding `vals`
    case (G1, H1, call: <prim-callable>) -> call(*vals, G, H)

    otherwise -> <Execution Halt>  -- the caller must be a Val

<builtin-val> : string -> Val
<builtin-val>(id) :=
   match id in
     case 'int' -> <prim-int-type>
     case 'list' -> <prim-list-type>
     ...
\end{verbatim}

\pycode|<Execution\ Halt>| is used in two ways in
here. Either it means that we found an operation that throws an
exception (which this formalisation does not handle), or it means that
the AST is malformed and nothing can be further calculated (an example
of this is using the wrong context, e.g.~\pycode|Load| when the value
required a \pycode|Store| context).

Note: Regarding the semi-casual notation used in here,
\pycode|type(Something)| is meant to be a shorthand to expanding on the
definition of \pycode|Something|. The porpuse is to make the code a
little bit more intelligible.

Notice that we make use of \pycode|get_prim_op| to find the appropiate
primitive function to operate two different values. Later, when we
extend Python with NumPy arrays will extend \pycode|get_prim_op| to
work with them.

\begin{verbatim}
TypeVals = Type U {Int, Float, Bool, NoneType}
get_prim_op :: Op x TypeVals x TypeVals -> <prim-callable>
-- Type can be Int, Float, List, ...

get_prim_op(Add, t1, t2) :=
  match (type(v1), type(v2)) in
    case (Int, Int) -> <prim-+-int>
    case (Float, Float) -> <prim-+-float>
    case (Int, Bool) -> \(i, j, G, H)-> <prim-+-int>(i, Int(j), G, H)
    case (Bool, Int) -> \(i, j, G, H)-> <prim-+-int>(Int(i), j, G, H)
    case (Float, a) -> if a = Bool or a = Int
                       then \(i, j, G, H)-> <prim-+-float>(i, Float(j), G, H)
                       else <Execution Halt>
    case (a, Float) -> if a = Bool or a = Int
                       then \(i, j, G, H)-> <prim-+-float>(Float(i), j, G, H)
                       else <Execution Halt>
    -- This function is to be extended once we add NdArrays to the mix
    case otherwise -> <Execution Halt>
\end{verbatim}

As an example, \pycode|<prim-+-int>| is defined
as the function:

\begin{pythoncode}
<prim-+-int>(i, j, G, H) := (G, H, i+j)|
\end{pythoncode}

{\nonsection{Statements Semantics}}

The semantic of statements is a function between the state of the
program, just like it was done with expressions. Unlike with expresions,
the semantics of statements do not return any kind of value, they just
modify the state of the program.

\begin{verbatim}
S[Assign(var, val)](G, H) :=
  let (G1, H1, ass) := E[var](G, H)
      (G2, H2, rightval) := E[val](G1, H1)
      rval := if is_value(rightval) then val else <Execution Halt>
   in
      match ass in
        case Iden -> (G2[ass->rval], H2)

        case ((t, addr, o): Object, ('index', val: Val)) ->
          let setindex := get_prim_set_index(t)
          in setindex(G2, H2, o, val, addr, rval)

        -- This case doesn't come up, it is only required when when user objects
        -- are allowed
        -- case ((t, addr, o): Object, ('attr', val: Val)) ->
        --    let

        otherwise -> <Execution Halt>

-- Behaviour in Python 4
S[AnnAssign(var, hint, val)](G, H) := S[Assign(var, val)](G, H)

-- Behaviour in Python 3
S[AnnAssign(var, hint, val)](G, H) :=
  let (G1, H1, evaluatedhint) := E[hint](G, H)  -- In Python 3 the hint is computed
   in S[Assign(var, val)](G1, H1)

get_prim_set_index : Type
                   -> type(G) x type(H) x (Key -> Undefined + Addr) x Val x Addr x Val
                   -> type(G) x type(H)
get_prim_set_index(List)(G, H, o, ind, addr, rval) :=
  if kind(ind) /= Int
  then <Execution Halt>
  else if 0 <= ind and ind < o('size') -- negative cases can be added later
  then
     let newlst := (List, addr, o[ind->rval])
      in (G, H[addr->newo])
  else <Execution Halt>
get_prim_set_index(Tuple)(G, H, o, ind, addr, rval) := <Execution Halt>
get_prim_set_index(_)(G, H, o, ind, addr, rval) := <Execution Halt>

S[Delete(e)](G, H) :=
  let (G1, H1, a) := E[e](G, H)
   in
      match a in
         case Val -> <Execution Halt>
         case Addr -> <Execution Halt> -- e should have returned a way to find the place to remove the value
         case Iden -> (G[e -> Undefined], H)
         case ((type, addr, o): Object, key: (string x Val)) ->
           let del := get_prim_delete(type, key)
            in del(G1, H1, o, addr)

get_prim_delete(List, key) :=
  match key in
    case ('index', val: Val) ->
      <prim-del-index-list>(val)
    otherwise -> <Execution Halt>
get_prim_delete(Tuple, key) := <Execution Halt>
-- other get_prim_delete could be added, for example if attributes could be deleted (only
-- with user defined objects)

<prim-del-index-list> : Val
                      -> Global x Heap x (Key -> Undefined + Addr) x Addr
                      -> Global x Heap
<prim-del-index-list>(ind)(G, H, lst, addr) :=
  if type(ind) /= Int
  then <Execution Halt>
  else
       if ind < lst('size') and ind >= 0 -- Other cases to handle are when ind < 0, in Python that is valid!
       then let newlst1 := shift-left-ind-in-list(lst, ind, lst('size'))
                newlst2 := newlst1[('index', size-1)->Undefined]
             in (G, H[addr->newlst2])
       else <Execution Halt>

shift-left-ind-in-list(lst, ind, size) :=
  if ind < size - 1
  then shift-left-ind-in-list(lst[('index', ind)->lst('index', ind+1)], ind+1, size)
  else lst

-- Import will be defined later once we introduce the NumPy library
S[Import(name)](G, H) := <Execution Halt>
\end{verbatim}

Notice that type annotations behave differently in Python 4 to Python
3.6+. Type annotations in Python 3.6+ are just regular expressions in
the language, are evaluated and can modify the state of the program. For
Python 4, it is planned that Type annotations will not modify the state
of the program\footnote{Well, this is not strictly true. In both, Python
  3.6+ and Python 4, type annotations are stored in the special variable
  \pycode|__annotations__|. {\inlinetodo{add ref to peps where this
  is described}}} but must obey the syntax of Python {\todo{add ref to
pep}}. In Python 3.7 a \pycode|__future__| import was added to
modify the behaviour/semantics of Type Annotations for Python 3.7+. One
can add \pycode|from __future__ import annotations|
at the start of the file to forgo the evaluation of type annotations. We
assume in this work that the type annotations do not alter the state,
i.e.~we assume that the user implicitely or explicitely is using the
\pycode|annotations|' future statement.

In this formalisation, the delete statement is only able to delete
variables in the global scope, but cannot delete attributes of an
object. This limitation comes from the fact that, the formalisation
lacks the capacity to define user-defined classes. Future work will
focus on extending the state model to include function variable scope,
and the ability to define functions and classes.

\subsection{NdArrays}\label{ndarrays}

The purpose of the formalisation is to be able to construct from it an
Abstract Interpreter. To test the Abstract Interpreter abilities to find
bugs it should be able to handle NumPy array (tensors). In this
subchapter, I extend the formalisation with NumPy array and discuss some
of their semantics.

The following are all the things to take into account when extending our
formalisation to handle a new type of \enquote{builtin} \pycode|Object|
type:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Extend the types of \pycode|Object|s to handle NumPy arrays.

\begin{verbatim}
Type = List | Tuple | Module | NdArray
\end{verbatim}

  As an example, consider the numpy array \pycode|np.zeros((4, 3))|, it
  can be expressed as:

\begin{verbatim}
Object(NdArray,
 0xanumber,
 -- The shape of a NdArray is a tuple of integers
 { 'shape' -> Object(Tuple,
               0xothernum,
               { 'size' -> 2,
                 ('index', 0) -> 4,
                 ('index', 1) -> 3,
               }
              )
   ('index', 0) -> 0,
   ... -- all other indices, each one identified by an integer
 }
)
\end{verbatim}

  Note: Remember that an \pycode|Object| is a triple of the form
  \pycode|Type x Addr x (Key -> Addr + Undefined)|.
  Also remember that example above is faulty as the codomain of the
  function defined above is \pycode|Val| not \pycode|Addr| as it should
  be.
\item
  Extend primitive functions with NumPy's primitive functions. The
  NumPy's primitive functions implemented in the Abstract Interpreter
  are: \pycode|array|, \pycode|zeros|, \pycode|dot|, \pycode|ones|,
  \pycode|abs| (and all other functions that don't alter the shape of
  the tensor they take), \pycode|arange|, \pycode|size|, \pycode|ndim|,
  \pycode|astype|, and \pycode|T|.

\begin{verbatim}
<prim-callable> = ... (old operations) |
                  <prim-np-zeros> | <prim-np-dot> | <prim-np-abs> | ...
\end{verbatim}

  Note: The values stored inside a NumPy array are consider irrelevant
  in this work. The Value Analysis built in this work considers only the
  shape of tensors, as tensors can be huge and their contents do not
  often influence their shape. Therefore, it would be wasteful to give a
  detailed formalisation of the NumPy library primitives.

  Nonetheless, defining formaly each one of the NumPy functions above is
  fairly straightforward. Although, the hardest part of a formal
  defitinion of Numpy arrays is detailing how \pycode|array| works. To
  define the function \pycode|<np-array>| one
  must consider the many input cases it can handle, and it can handle
  almost any Python object\footnote{The NumPy function \pycode|array|
    takes almost anything as an input. \pycode|arrays| tries to
    interpret its input as an array in any way it can. There is no
    formal definition of how the values are interpreted althought its
    semantics can be extracted by looking at its C implementation:
    https://stackoverflow.com/a/40380014}.

  Once the \pycode|<np-array>| function is
  implemented all other functions are much simpler to define. As an
  example, the implementation of the function \pycode|size| is:

\begin{verbatim}
<prim-np-size>(val)(G, H) :=
   -- We know that `<prim-array>` always returns an NdArray
   let (G, H, (NdArray, addr, arr)) := <prim-array>(val)(G, H)
   -- We know that a NdArray has a special value called `shape`
       (Tuple, addrtup, tup) := arr('shape')
   in  tup('size')
\end{verbatim}
\item
  Extend the cases that \pycode|get_prim_op| handles to cover NumPy
  arrays. All operations defined in NumPy handle broadcasting.
  {\todo{Explain what broadcasting is}} For example:

\begin{verbatim}
get_prim_op(Add, t1, t2) :=
  match (type(v1), type(v2)) in
    ... -- old cases
    case (NdArray, t1) ->
      \(i, j, G, H)->
        let (G2, H2, ndarr) := <prim-array>(j)(G, H)
        in  <prim-+-ndarray>(i, ndarr, G2, H2)
    case (t1, NdArray) ->
      \(i, j, G, H)->
        let (G2, H2, ndarr) := <prim-array>(i)(G, H)
        in  <prim-+-ndarray>(ndarr, j, G2, H2)
    case otherwise -> <Execution Halt>
\end{verbatim}
\item
  The NumPy module holding all operations is defined:

\begin{verbatim}
<numpy-mod> := Object(Module,
 -1,  -- This value will be changed once it is imported
 { ('attr', 'array') -> <prim-array>,
   ('attr', 'dot')   -> <prim-dot>,
   ('attr', 'zeros') -> <prim-zeros>,
   ('attr', 'ones')  -> <prim-ones>,
   ...
 }
)
\end{verbatim}
\item
  And finally, \pycode|S[Import(name)]| is extended (now it handles
  a single library):

\begin{verbatim}
S[Import(name)](G, H) :=
  match name in
    ("numpy",) ->
      let (Module, arr, mod) := <numpy-mod>
          freeaddr := get_free_addr(H)
      in  (G['numpy'->freeaddr], H[freeaddr->(Module, freeaddr, mod)])
    ("numpy", alias) ->
      let (Module, arr, mod) := <numpy-mod>
          freeaddr := get_free_addr(H)
      in  (G[alias->freeaddr], H[freeaddr->(Module, freeaddr, mod)])

    otherwise -> <Execution Halt>
\end{verbatim}
\end{enumerate}

\section{Abstract Interpreter}\label{abstract-interpreter}

{\ichange{This is just a DRAFT! REVISE!!}}

We have the base to build an Abstract Interpreter, we have the semantics
of Python (what is a variable, what is the state of the program, and how
to modify the program (its formal semantics)).

The steps to build an Abstract Interpreter are:

\begin{itemize}
\tightlist
\item
  Define a Variable Abstract Domain,
\item
  Define a State Abstract Domain, and
\item
  Define the abstract semantics for the language.
\end{itemize}

\subsection{Variable Abstract Domain}\label{variable-abstract-domain}

Remember, the possible values that a variable may have in Python are:

\begin{verbatim}
PrimVal = Int | Float | True | False | None | Undefined
Object = Type x Addr x (Key -> Addr + Undefined)
Val = PrimVal | Object | <prim-callable>

Type = List | Tuple | Module | NdArray
\end{verbatim}

The definition of \pycode|Val| is a recursive but not the definition of
\pycode|PrimVal|. We will start defining an Abstract Domain for
\pycode|PrimVal|s and later we will expand on it to define a
\enquote{recursive} definition for the Abstract Domain of \pycode|Val|s.

\subsubsection{\texorpdfstring{\pycode|PrimVal| Abstract
Domain}{PrimVal Abstract Domain}}\label{primval-abstract-domain}

\pycode|PrimVal| is composed of five different types: \pycode|int|,
\pycode|float|, \pycode|bool|, \pycode|NoneType|, and
\pycode|Undefined|. We can define individual non-relational Abstract
Domains\footnote{A relational Abstract Domain is an Abstract Domain
  where the value of variables is not assumed to be independent of each
  other. For more information on relational Abstract Domains look at
  {\inlinetodo{add ref to octagons thesis}}. All Abstract Domains used
  in this work are non-relational Abstract Domains as they are simpler
  to understand and implement. Future work will include extending the
  arange of Abstract Domains to use to some relational Abstract Domains.}
(AD) for each of the types.

The simplest of all AD is that of \pycode|NoneType|. \pycode|None| is
the only inhabitant of \pycode|NoneType|. There is only one order for a
set of one element, the trivial order: \(\text{None} \le \text{None}\).
The Galois connection for a trivial order is also very simple:
\(\alpha(None) = None^{\#}\) and \(\gamma(None) = None^{\#}\).

A little bit more interesting is the AD for \pycode|bool|. \pycode|bool|
is inhabited only by \pycode|True| and \pycode|False|. We define the
following order:

{\inlinetodo{translate figure to latex}}

\begin{verbatim}
    Top_{Bool#}
     /      \
  True#    False#
     \      /
    Bot_{Bool#}
\end{verbatim}

The Galois connection for this lattice is also quite simple:

\begin{align*}
  \alpha \colon \mathcal{P}(\text{Bool}) &\to \text{Bool}^{\#} \\
  \emptyset &\mapsto \bot^{\text{Bool}} \\
  \{True\} &\mapsto True^{\#} \\
  \{False\} &\mapsto False^{\#} \\
  \{True,False\} &\mapsto \top^{\text{Bool}} \\
\end{align*}

Where \(\gamma{}\) is just defined as \(\alpha^{-1}\) given
\(\alpha{}\)'s bijectivity.

Notice how our previous two Abstract Domains do not require us to define
widening or narrowing operators because none of them has a

For \pycode|int| and \pycode|float| there a plenty different different
options. For some of them take a look at {\todo{add ref to octagons
thesis}}. We are going to use here, probably, the simplest AD for number
systems there is Constant Propagation {\todo{add ref to Kil73 (from
octagons thesis)}}.

Constant Propagation is very simple, in fact both \pycode|None#| and
\pycode|Bool#| are Constant Propagation Abstract Domains. We define
\pycode|int|'s AD as:

{\inlinetodo{translate figure to latex}}

\begin{verbatim}
                  Top^Int
  _________________|_______________
 /     /     /          \     \    \
 0     1    -20 ...
 \_____\_____\__________/_____/____/
                   |
                  Bot^Int
\end{verbatim}

\textbf{Notation:} To keep things light, \(n^{\#}\) is represented as
\(n\).

In the same manner as with \(\text{Bool}^{\#}\), we define the Galois
connection as:

\begin{align*}
  \alpha \colon \mathcal{P}(\text{Int}) &\to \text{Int}^{\#} \\
  \emptyset &\mapsto \bot^{\text{Int}} \\
  \{n\} &\mapsto n \\
  otherwise &\mapsto \top^{\text{Int}} \\
\end{align*}

and

\begin{align*}
  \gamma \colon \text{Int}^{\#} &\to \mathcal{P}(\text{Int}) \\
  \bot^{\text{Int}} &\mapsto \emptyset \\
  n &\mapsto \{n\} \\
  \top^{\text{Int}} &\mapsto \text{Int} \\
\end{align*}

and

\begin{verbatim}
Int# = Int U {Top_int, Bot_int}
\end{verbatim}

We define \(\text{Float}^{\#}\) just in the same way.

Now that we have an Abstract Domain for each of \pycode|PrimVal|s we can
construct an AD for \pycode|PrimVal|. The idea is simple, as shown in
the image below we just define an Abstract Domain that groups them all
together and puts a value on top and one below all of them:

{\inlinetodo{translate figure to latex}}

\begin{verbatim}
                  Top_primvals
      _________________|_______________
     /             /                   \
   Top_int        Top_float
 ____|____     ____|____
/  /   \  \   /  /   \  \   Bool  Undefined NoneType
0  1   ...   .4 nan  ...
\__\___/__/   \__\___/__/
     |             |
   Bot_int        Bot_float
     \_____________\___________________/
                       |
                    Bot_primvals
\end{verbatim}

The formal definition is quite simple, let's consider only the Galois
connection as everything is quite straightforward:

{\inlinetodo{finish writing equation}}

\begin{align*}
  \alpha^{\text{PrimVal}} \colon \mathcal{P}(\text{PrimVal}) &\to \text{PrimVal}^{\#} \\
  \emptyset &\mapsto \bot^{\text{PrimVal}} \\
  \{n\} &\mapsto \text{check n and create the according value given the n type} \\
  otherwise &\mapsto \text{check if all elements belong to the same type (then same alpha)
  otherwise Top primval} \\
\end{align*}

This is not the only way to define an Abstract Domain out of other
Abstract Domains. In fact there are many ways, on of which is to define
an Abstract Domain where each is extended with \pycode|Undef| and they
are all packed into a tuple {\todo{add ref to Python AI by mile}}.

{\todo{this is lacking a proper proof of the Galois connection
property}}

\subsubsection{\texorpdfstring{\pycode|Val|s Abstract
Domain}{Vals Abstract Domain}}\label{vals-abstract-domain}

\noindent \textbf{\pycode|Val| definition}

Remember \pycode|Val|'s definition:

\begin{verbatim}
Val = PrimVal | Object | <prim-callable>
Object = Type x Addr x (Key -> Addr + Undefined)

Type = List | Tuple | Module | NdArray
Key = Iden + (string x (Iden + PrimVal))

Heap = Addr -> Val    -- Heap
\end{verbatim}

A couple of important details about \pycode|Val|'s definition:

\begin{itemize}
\tightlist
\item
  A \pycode|Val| can be a \pycode|PrimVal|, an \pycode|Object| or a
  \pycode|<prim-callable>|.
\item
  A \pycode|Val| is not isolated, it makes part of a bigger set of
  variables, all of them must be defined in \pycode|Heap|. Any
  \pycode|Val| we define must be stored in \pycode|H| \(\in\)
  \pycode|Heap|.
\item
  We say that a \((a, H) \in \text{Addr} \times \text{Heap}\) is a
  \textbf{valid} value if every value defined in \(H\):
  \(vars = \{v \in Img(H) : v \ne \text{Undefined}\}\) is reachable from
  \(H(a)\), and no \pycode|Addr| inside any defined \pycode|Object|
  points to \pycode|Undefined|.
\end{itemize}

An example of a possible value is \pycode|(0, H)| where \pycode|H| is
defined as:

\begin{verbatim}
H = {
  0: (List, 0, { 'size': 1, ('index', 0): 2, ('index', 1): 3, ('index', 2): 4}),
  1: 3,
  2: None,
  3: 4,
  4: (Tuple, 4, {'size': 5}),
  5: 0
}
\end{verbatim}

\textbf{Notation:} As in the previous subchapter we are using the Python
dictionary notation to define functions. \pycode|{0: 4, 1: 5}|
means \(0 \mapsto 4; 1 \mapsto 5\)

We shall remember this example from the previous subchapter, it
represents the list \pycode|[None, 4, ()]|.

Notice that the values \((1, H)\), \((2, H)\), \ldots{}, and \((5, H)\)
are not considered valid as it is impossible from them to reach all
other values in the Heap. For this section, all values will be valid
values. If we find a non-valid value \((n, H)\), we can define a new
value \((n, H')\) where \(H'\) has all non-reachable values removed.

{\nonsection{\(Val^\#\) definition}}

An Abstract Value is a tuple
\((a, H^\#) \in \text(Addr) \times \text(Val)^\#\) where:

\begin{verbatim}
Heap# = Addr -> Val# + Undefined    -- Abstract Heap

Val# = PrimVal# | Object# | <prim-callable># | Top_Val | Bot_Val
Object# = Type x Addr x ((Key -> Addr + Undefined) + ImTop + ImBot)
\end{verbatim}

Notice that a \pycode|Val#| requires a Heap to work! Just as
\pycode|Val| required it. Some examples of Abstract Values are
\((a, H^\#) \in Val^\# \times Heap^\#\) are:

\begin{verbatim}
(0, {0: 3})
(0, {0: Top_Int})
(0, {0: Bot_Bool})
(0, {0: Top_Val})

(0, {
  0: (List, 0, { 'size': 1, ('index', 0): 2, ('index', 1): 3, ('index', 2): 4}),
  1: Top_Int,
  2: (Tuple, 2, ImTop),
  3: 21,
  4: (Tuple, 4, {'size': 5}),
  5: Bot_Int
})
\end{verbatim}

Notice that we can represent any valid value \((a, H^\#)\) as a graph
with \(a\) as root:

{\inlinetodo{convert nodes below into latex figures}}

\begin{verbatim}
({1}, {1: 3}, {(1,1): Undefined}, 1)
  (3)

-- if a pair (a, b) \in V x V is not shown, then it is Undefined
({1}, {1: Top_Int}, {}, 1)
  (Top_Int)

({1}, {1: Top_Bool}, {}, 1)
  (Bot_Bool)

({1}, {1: Top_Val}, {}, 1)
  (Top_Val)

(0, {
  0: (List, 0, { 'size': 1, ('index', 0): 2, ('index', 1): 3, ('index', 2): 4}),
  1: Top_Int,
  2: (Tuple, 2, ImTop),
  3: 21,
  4: (Tuple, 4, {'size': 5}),
  5: Bot_Int
})

({0, 1, 2, 3, 4, 5, 6},
 {0: List,
  1: Top_Int,
  2: Top_Tuple,
  3: 21,
  4: Tuple,
  5: Bot_Int,
  },
  {(0,1): 'size',
   (0,2): ('index', 0),
   (0,3): ('index', 1),
   (0,4): ('index', 2),
   (4,5): 'size'
   },
   1)

  (List)
   |-- 'size'       -> (Top_Int)
   |-- ('index', 0) -> (Top_Tuple)
   |-- ('index', 1) -> (21)
   |-- ('index', 2) -> (Tuple)
                        |-- 'size' -> (Bot_Int)
\end{verbatim}

We have defined the first ingredient of the \pycode|Val| Abstract
Domain. The ingredients left are:

\begin{itemize}
\tightlist
\item
  Abstraction \(\alpha{}\) and concretisation \(\gamma{}\) functions,
\item
  an order relation,
\item
  join (\(\sqcup^{\text{Val}}\)) and merge (\(\sqcap^{\text{Val}}\))
  operations, and
\item
  a Galois connection.
\end{itemize}

{\nonsection{\(\cup^{\text{Val}^\#}\) definition}}

We will start by the defining the \emph{join} operation and the
rationale behind its innerworkings. All other operations and functions
are constructed in a very similar way as \emph{join} is defined.

\begin{verbatim}
Uval: (Addr x Heap#) x (Addr x Heap#) -> (Addr x Heap#)
(n, H1#) Uval (m, H2#) :=
  let on := H1#(n)
      om := H2#(m)
   in if on is Object# and om is Object#
      then let (n', joined, Hnew#) := joinVal((n, H1#), (m, H2#), join_empty, H_empty)
            in (n', removeallInConstruction(Hnew#, joined, H1#, H2#))
      else if on is PrimVal# and om is PrimVal#
      then (0, H_empty#[0->on UPrimVal# om])
      else if on = Bot_Val
      then (0, H_empty#[0->om])
      else if om = Bot_Val
      then (0, H_empty#[0->on])
      else if on = om  -- checking all other cases TopVal = TopVal, <prim-_> = <prim-_>, ...
      then (0, H_empty#[0->on])
      -- the last case is when the two values have different types altogether
      else (0, H_empty#[0->Top_Val])

join_empty: Addr x Addr -> (Addr + Undefined)
join_emtpy(a,b) := Undefined

H_empty: Heap#
H_empty(a) := Undefined
\end{verbatim}

\emph{join} revises the kinds\footnote{check if this is the right word
  to use} of both values and defines a value that unifies them, they
follow the following sensible rules:

\begin{itemize}
\tightlist
\item
  \pycode|Bot_Val| must be the lowest value in the order, therefore any
  value joining with it should be the same value
  (\pycode|Bot_Val U n = n|).
\item
  \pycode|Top_Val| is the biggest value in the order, therefore any
  value joining with it should give back \pycode|Top_Val|
  (\pycode|Top_Val U n = Top_Val|).
\item
  Values of the same kind, \pycode|PrimVal#|, \pycode|Object#| and
  \pycode|<prim-callable>|, should not be
  comparable, e.g.~any value from \pycode|PrimVal#| joined with any of
  \pycode|Object#| should give \pycode|Top_Val|.
\item
  Joining \pycode|PrimVal#|s should use \pycode|UPrimVal#|.
\item
  Joining \pycode|Object#|s should take into account the recursive
  nature of the defitinion of \pycode|Val#|s and \pycode|Object#|s.
\end{itemize}

Notice tha it is \pycode|joinVal| where the whole magic of this Abstract
Domain lies. \pycode|joinVal| is meant walk through both graphs
simultaneously, find the similarities, implode the differences between
the graphs and preserve the equaly looking parts.

The definition of \pycode|joinVal| requires the help of the function
\pycode|joinObjectFn| which joins the values to which an
\pycode|Object#| points (the function
\pycode|(Key -> Addr + Undefined)|).

\begin{verbatim}
HeapCon# = Addr -> Val# + Undefined + InConstruction

-- we assume that (n,H1#) and (n,H1#) are Object#s
joinVal: (Addr x Heap#) x (Addr x Heap#) x (Addr x Addr -> Addr + Undefined) x HeapCon#
       -> Addr x (Addr x Addr -> Addr + Undefined) x HeapCon#
joinVal((n,H1#), (m, H2#), joined, H_new#) :=
  let joined_left := {l \in Addr | E r \in Addr : joined(l,r) != Undefined}
      joined_right := {r \in Addr | E l \in Addr : joined(l,r) != Undefined}

   in if n in joined_left or m in joined left -- n or m has alredy been visited
      then  if joined(n, m) != Undefined -- an address for the new Object# has already been defined
            then (joined(n,m), joined, H_new#)
            -- either n or m had already been joined to other object, every variable they
            -- can reach should be Top_Val because the paths to reach them are different
            -- in the two states
            else let (joined', H_new'#) := makeallreachabletop((n, H1#), (m, H2#), joined, H_new#)
                     ad := freeaddr(H_new'#)
                  in (ad, joined[(n,m)->add], H_new'#[ad->Top_Val])
      -- we know that H1#(n) and H2#(m) are both 'Object#'s because the call from UVal#
      -- checked so
      else let -- n and m haven't already been visited
             (tn, adn, fn) := H1#(n)
             (tm, adm, fm) := H2#(m)
        in if tn != tm -- the two Object#s are not of the same type
           then let (joined', H_new'#) := makeallreachabletop((n, H1#), (m, H2#), joined, H_new#)
                    ad := freeaddr(H_new'#)
                 in (ad, joined[(n,m)->add], H_new'#[ad->Top_Val])
           -- both objects have the same type
           else if fn = ImTop and fm = ImTop
                then let ad := freeaddr(H_new'#)
                      in (ad, joined[(n,m)->ad], H_new#[ad->(tn,ad,ImTop)])
                else if fn = ImTop
                then let (joined', H_new'#) := makeallreachabletop_right((m, H2#), joined, H_new#)
                         ad := freeaddr(H_new'#)
                      in (ad, joined'[(n,m)->ad], H_new'#[ad->Top_Val])
                else if fm = ImTop
                then let (joined', H_new'#) := makeallreachabletop_left((n, H1#), joined, H_new#)
                         ad := freeaddr(H_new'#)
                      in (ad, joined'[(n,m)->ad], H_new'#[ad->Top_Val])
                -- if any of the two values is Bot then we leave the new value as
                -- InConstruction until the end of the execution
                else if fn = ImBot or fm = ImBot
                then let adnew := freeaddr(H_new#)
                      in (adnew, joined[(m,n)->adnew], H_new#[adnew->InConstruction])
                -- both, fn and fn, are (Key -> Addr + Undefined)
                -- notice that `InConstruction` is assigned to the address `ad`, but once
                -- we return from the recursive call we can now replace the value for a
                -- proper object definition
                else let ad := freeaddr(H_new#)
                         (fnew, joined', H_new'#) := joinObjectFn((fn, H1#),
                                                                  (fm, H2#),
                                                                  joined[(n,m)->ad],
                                                                  H_new#[ad->InConstruction])
                      in if H_new'#(ad) = InConstruction
                         then (ad, joined', H_new'#[ad->(nt, ad, fnew)])
                         else (ad, joined', H_new'#)

joinObjectFn: ((Key -> Addr + Undefined) x Heap#) x ((Key -> Addr + Undefined) x Heap#)
            x (Addr x Addr -> Addr + Undefined) x HeapCon#
            -> (Key -> Addr + Undefined) x (Addr x Addr -> Addr + Undefined) x HeapCon#
joinObjectFn((fn, H1#), (fm, H2#), joined, H_new#) :=
   let fn_empty: (Key -> Addr + Undefined)
       fn_empty = Undefined

       PreIm: (Key -> Addr + Undefined) -> P(Key)
       PreIm(fun) := {ad \in Addr | fun(ad) != Undefined}

       helper: ((Key -> Addr + Undefined) x (Addr x Addr -> Addr + Undefined) x HeapCon#)
               x Key
               -> ((Key -> Addr + Undefined) x (Addr x Addr -> Addr + Undefined) x HeapCon#)
       helper((fnew, joined, H_new#), key) :=
         if fm(key) = Undefined
         then let (joined', H_new'#) := makeallreachabletop_left((fn(key), H1#), joined, H_new#)
                  ad := freeadd(H_new'#)
               in (fnew[key->ad], joined', H_new'#[ad->Top_Val])
         else if fn(key) = Undefined
         then let (joined', H_new'#) := makeallreachabletop_right((fm(key), H2#), joined, H_new#)
                  ad := freeadd(H_new'#)
               in (fnew[key->ad], joined', H_new'#[ad->Top_Val])
         -- key is defined in both, fn and fm
         else let
            adn := fn(key)
            adm := fm(key)
            val1 := H1#(adn)
            val2 := H2#(adm)
            ad := freeadd(H_new'#)

         -- same code that was in
         in if val1 is Object# and val2 is Object#
            then let (n', joined', H_new'#) = joinVal((n, H1#), (m, H2#), joined, H_new#)
                  in (fnew[key->n'], joined', H_new'#)
            else if val1 is PrimVal# and val2 is PrimVal#
            then (fnew[key->ad], joined[(adn,adm)->ad], H_new#[ad->val1 UPrimVal# val2])
            else if on = Bot_Val
            then (fnew[key->ad], joined[(adn,adm)->ad], H_new#[ad->InConstruction])
            else if val2 = Bot_Val
            then (fnew[key->ad], joined[(adn,adm)->ad], H_new#[ad->InConstruction])
            else if on = val2  -- checking all other cases TopVal = TopVal, <prim-_> = <prim-_>, ...
            then (fnew[key->ad], joined[(adn,adm)->ad], H_new#[ad->on])
            -- the last case is when the two values have different types altogether
            else (fnew[key->ad], joined[(adn,adm)->ad], H_new#[ad->Top_Val])

    in foldl(helper, (fn_emtpy, joined, H_new#), PreIm(fn) U PreIm(fm))
\end{verbatim}

{\inlinetodo{there are a couple of functions missing, one of them is
\pycode|makealltop|}}

\pycode|joined| is a function that stores the similarities between nodes
(values), and \pycode|Hnew#| stores the values of each new value. The
type of \pycode|Hnew#| is not \pycode|Heap#| but
\pycode|Addr -> Val# + Undefined + InConstruction|
(the output of \pycode|Heap#| extended with an \pycode|InConstruction|
new value). The new value to which a heap can point to is
\pycode|InConstruction| and it is meant to be a wildcard value while the
graph is being constructed.

{\inlinetodo{Reconsider eliminating the whole paragraph from below: We
will never see a Bottom value in Pytropos, as the only way for it to
appear would be to \emph{merge} two values, but that is never going to
happen as \emph{merge} was not defined because there is never a use for
it (the only way to use \emph{merge} would be by incoporating backward
assignment, which is out of the scope of Pytropos)}}

One last function, that was not explained before is
\pycode|removeallInConstruction|. It is in charge of looking in the Heap
if there is one reference to some \pycode|InConstruction| value left.
All \pycode|InConstruction| values left after returning from the whole
walk will be only those which appeared when joining some node to a
\pycode|ImBot| or \pycode|Bot_Val|. Because we expect
\pycode|ImBot U fn = fn|, we must copy all values from the joining
heaps into the new heap.

Because the \enquote{code} describing how to \emph{join} to abstract
values can be rather coarsed, we present to you the algorithm working in
a couple of examples. The two graphs at the left represent the two
values to join, on the right the resulting new value is defined.

{\inlinetodo{show six examples of uniting different values, they can be
as complicated as possible. \texttt{1 U 2},
\texttt{[1,2]\ U\ [1,3]},
\texttt{a = [2, 3]; a.append(a)} (extract three more examples
from tests)}}

{\inlinetodo{Add note saying that this scheme of Abstract Domain is
general enough to let us switch between different non-relation AD for
the PrimVals. There are probably some tweaks necessary to allow this AD
to work with relational ADs for the PrimVals}}

{\nonsection{\(Val^\#\) Order definition}}

Now that we have defined the \emph{join} function, we can move to the
function that defines a lattice a lattice.

We define \(\le{}\) as \(a \le b \iff b = a \sqcup b\). This definition
follows from the definition of \emph{join} (based on the order): given
any two values \(a,b \in\) lattice, it is always possible to find a
value that is bigger than \(a\) and \(b\) such that it is the smallest
of the bigger values. In the case \(a < b\), then we can be certain that
\(b\) will be the \emph{join} of \(a\) and \(b\), otherwise there would
be a value smaller than \(b\) that is also bigger or equal than \(b\).
That means, that we can define a lattice by either defining an order
relation or a proper \emph{join} operation. We leave the proof that
\(\le{}\) defines an order for valid values
(\texttt{v\ \textbackslash{}in\ Addr\ x\ Heap\#}) for future work.

{\nonsection{Other definitions}}

My goal is not to present in detail all functions and operations
necessary to define the AD for \texttt{Val\#}s. That would require three
times the space already used in this document, and would be tedious.
What I wanted to show here is the rationale behind the implementation to
give it a little more formal depth.

The \emph{merge} operation is defined as it was \emph{join}. The main
difference between the two is what is the result of operating two values
with different types. For \emph{join} different types give us
\texttt{Top} and for \emph{merge} we get \texttt{Bottom}.

\subsection{State Abstract Domain}\label{state-abstract-domain-1}

Now that we have a Value Abstract Domain, we can extend it to the State
of a Program. Doing so it's surprisingly easy, as all the blocks have
already been laid down by the Value Abstract Domain.

The State Abstract Domain is defined as the tuple
\texttt{(Global\#,\ Heap\#)} where:

\begin{verbatim}
-- Global
Global# = Iden -> Addr + Undefined  -- Abstract Global Scope
-- Heap
Heap# = Addr -> Val# + Undefined    -- Abstract Heap
\end{verbatim}

Notice that \texttt{Global\#} is a function that takes an identifier and
outputs an address to where the variable is stored, which is just the
same thing that the function
\texttt{Key-\textgreater{}\ Addr\ +\ Undefined} inside \texttt{Object\#}
does. In fact, the function inside \texttt{Object\#} has a bigger
pre-image than that of \texttt{Global\#} (\texttt{Key} is defined as
\texttt{Iden\ +\ (string\ x\ (Iden\ +\ PrimVal))}). This means that we
have no need to define a \emph{join} operation from scratch for the
State Abstract Domain but we just borrow repurpose
\texttt{joinObjectFun}!

\begin{verbatim}
UState: (Global#, Heap#) x (Global#, Heap#) -> (Global#, Heap#)
(G1#, H1#) UState (G2#, H2#) :=
  let (Gnew#, joined, Hnew#) = joinObjectFn((G1#, H1#), (G2#, H2#), joined_empty, H_empty)
   in (Gnew#, Hnew#)
\end{verbatim}

Similarly all other functions and operations can be defined as a special
case of the Value Abstract Domain.

\subsection{Abstract Semantics}\label{abstract-semantics-1}

In this section, I present some examples of the abstract semantics.
Notice that we do not need the abstraction and concretatisation
functions as the State and State Abstract Domains are quite similar. It
is left for future work to proof that the definitions stated in here are
in fact derived from the Galois connection.

As examples, consider the semantics of expressions:

\begin{verbatim}
E#[expr] :: Global# x Heap#
         -> Global#
          x Heap#
          x (Val# + Addr + (Object# x (string x Val#)) + Iden)

E#[Name(id, ctx)](G#, H#) :=
  match ctx in
    case Load  -> if G#(id) = Undefined
                  -- the variable `id` has not been defined then we "set" it in the global
                  -- scope and return `Top_Val`
                  then let ad := freeaddr(H#)
                        in (G#[id->ad], H#[ad->Top_Val], Top_Val)
                  else (G#, H#, G#(id))
    case Store -> (G, H, id)
    case Del   -> (G, H, id)

E#[BinOp(op, a, b)](G#, H#) :=
  let (G1#, H1#, v1) := E#[a](G#, H#)
      (G2#, H2#, v2) := E#[b](G1#, H1#)
      -- TODO: careful with the two notations you are using to make sure a var is Val#
      --        kind(v) = Val#  vs  isvalue#(v)
   in if kind(v1) /= Val#  or  kind(v1) /= Val#
      -- Bad parsing! `E[e](G, H)` for e in {a,b} are supposed to return Val#
      -- Parsing errors halt the execution of the Abstract Interpreter
      then <Execution Halt>
      else
        let prim_op# := get_prim_op#(op, type(v1), type(v2))
         in prim_op#(v1, v2, G2#, H2#)

TypeVals = Type U {Int, Float, Bool, NoneType}
get_prim_op# :: Op x TypeVals x TypeVals -> <prim-callable>#

get_prim_op#(Add, t1, t2) :=
  match (type(v1), type(v2)) in
    case (Int, Int) -> <prim-+-int>#
    case (Float, Float) -> <prim-+-float>#
    case (Int, Bool) -> \(i, j, G#, H#)-> <prim-+-int>#(i, Int(j), G#, H#)
    case (Bool, Int) -> \(i, j, G#, H#)-> <prim-+-int>#(Int(i), j, G#, H#)
    case (Float, a) -> if a = Bool or a = Int
                       then \(i, j, G#, H#)-> <prim-+-float>#(i, Float(j), G#, H#)
                       else <prim-ret-top>#
    case (a, Float) -> if a = Bool or a = Int
                       then \(i, j, G#, H#)-> <prim-+-float>#(Float(i), j, G#, H#)
                       else <prim-ret-top>#
    -- This function is to be extended once we add NdArrays to the mix
    case otherwise -> <prim-op-top>#

<prim-op-top># : Val# x Val# x Global# x Heap#
<prim-op-top>#(a, b, G#, H#) := (G#, H#, Top_Val)
\end{verbatim}

Notice that parsing errors still halt the execution of the Abstract
Interpreter. It could be possible to work around those errors too, but
parsing errors out of the scope of the Abstract Interpreter as they hint
to an external problem. We assume that a piece of code is parsed
properly before starting the execution of the code (just as Python
does).

Every function defined in the formal semantics of Python must be
rewritten as function that operates in the Abstract Domain. For example,
consider the function \texttt{\textless{}prim-+-int\textgreater{}}, it
is defined as:

\texttt{\textless{}prim-+-int\textgreater{}(i,\ j,\ G,\ H)\ :=\ (G,\ H,\ i+j)}

We need to define its Abstract Interpretation counterpart:

\begin{verbatim}
<prim-+-int>#(i, j, G#, H#) :=
  if i = Top_Int or j = Top_Int
  then (G#, H#, Top_Int)
  else if i = Bot_Int or j = Bot_Int
  then (G#, H#, Bot_Int)
  else (G#, H#, i+j)
\end{verbatim}

And as an example for the semantics of statements consider:

\begin{verbatim}
S#[Assign(var, val)](G#, H#) :=
  let (G1#, H1#, ass) := E[var](G#, H#)
      (G2#, H2#, rightval) := E[val](G1#, H1#)
      -- Parsing error, probably. `rightval` must be a `Val#` if the parsing made no mistake
      rval := if is_value#(rightval) then val else <Execution Halt>
   in
      match ass in
        case Iden -> (G2#[ass->rval], H2#)

        case ((t, addr, o): Object#, ('index', val: PrimVal#)) ->
          let setindex# := get_prim_set_index#(t)
          in setindex#(G2#, H2#, o, val, addr, rval)

        -- Parsing error probably. This should never have happened
        otherwise -> <Execution Halt>

S#[Import(name)](G#, H#) :=
  let freeaddr := get_free_addr(H#)
   in
     match name in
       ("numpy",) ->
         let (Module, arr, mod) := <numpy-mod>
         in  (G#['numpy'->freeaddr], H#[freeaddr->(Module, freeaddr, mod)])
       ("numpy", alias) ->
         let (Module, arr, mod) := <numpy-mod>
         in  (G#[alias->freeaddr], H#[freeaddr->(Module, freeaddr, mod)])

       ("pytropos.hints.numpy",) ->
          (G#["pytropos.hints.numpy"->freeaddr], H#[freeaddr->(Module, freeaddr, <numpy-hints>)])
       ("pytropos.hints.numpy", alias) ->
          (G#[alias->freeaddr], H#[freeaddr->(Module, freeaddr, <numpy-hints>)])

       (nm,) ->
          (G#[nm->freeaddr], H#[freeaddr->(Module, freeaddr, ImTop)])

       (nm,alias) ->
          (G#[alias->freeaddr], H#[freeaddr->(Module, freeaddr, ImTop)])
\end{verbatim}

\subsection{Type Annotations}\label{type-annotations}

I left out, purposefully, the abstract semantics of \pycode|AnnAssign|.
The idea of type annotations is that they let us refine the value/type
of a variable when the Abstract Interpreter is unable to define a
precise value.

An example of what annotations should be able to do is:

\begin{pythoncode}
from mypreciouslib import amatrix
from pytropos.hints.numpy import NdArray

mat: NdArray[1,12,6,7] = np.array(amatrix)
newmat = (mat + 12).reshape((12*6, -1))  # newmat has shape (12*6,7)
newmat = newmat.dot(np.ones((8, 21)))  # Error! Matrix multiplication, 7!=8
\end{pythoncode}

When one imports an arbitrary library like \texttt{mypreciouslib} it is
impossible to know what we may have imported so every variable imported
is a \texttt{Top\_Val}, i.e.~anything. By adding an annotation to
\texttt{mat}, we are telling the abstract interpreter that we know, and
are sure, of the shape of the NumPy array.

The semantics for \texttt{AnnAssign} are:

\begin{verbatim}
S[AnnAssign(var, hint, val)](G, H) :=
  let (G1, H1, evaluatedhint) := E[hint](G, H)
      (G2, H2, evaluatedhint) := E[hint](G1, H1)
      hintval := if isvalue#(evaluatedhint) then evaluatedhint else <Execution Halt>

   in S[Assign(var, val)](G1, H1)

  let (G1, H1, ass) := E[var](G, H)
      (G2, H2, evaledhint) := E[hint](G1, H1)
      (G3, H3, rightval) := E[val](G2, H2)
      compval := if is_value(rightval) then val else <Execution Halt>
      hintval := if isvalue#(evaledhint) then evaledhint else <Execution Halt>

      -- if `hintval` is more precise than `compval` we replace it
      rval := if hintval < compval then hintval else compval
   in
      ... -- Continue as in S[Assign(...)]
\end{verbatim}

Notice that we determine the \enquote{precision} of a hint with respect
to the variable with the comparision between values, the order
\texttt{\textless{}Val\#}!
