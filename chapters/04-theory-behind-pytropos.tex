\chapter{Abstract Interpretation for Python}\label{ai-for-python}

\ichange{Well, here I am again. Trying to write whatever comes to my mind, lets hope it is
something understandable or nice}

% So, I was talking with my advisors today. They told me that the theoretical part I was
% writing was totally unfounded. Well, not precisely, what they told me is that I didn't
% have clear what the heck was I doing, and they're right. I just tried to formalise
% whatever I had done because I did notice that I just could. Now, the things they told me
% to take into account were:
% - explain a little what types of semantics there are, if you are going to use them
%   better understand where are you sitting;
% - explain why this kind of semantics especifically an not any other; what means
%   semantics for you and what is the purpose of semantics (Expr -> State -> State);
% - with a very small example show how the semantics of your small language work (how are
%   the semantics of E[BinOp(+, 2, 4)](G, H)), it will probably need taking the definition
%   from the appendix;
% - now that the concrete semantics are clear, explain how are abstract semantics defined,
%   what makes them different (spoiler, the main difference is that they work with
%   abstract values and abstract states, and therefore are called abstract semantics)

In this chapter, an Abstract Interpreter for Python is proposed. The chapter is divided
into three: what are semantics, concrete semantics for Value Analysis of Python code, and
abstract semantics. This chapter is intended as a guide on how was the Abstract
Interpreter built and why was it built the way it is. A deeper look on the gory details
of the concrete and abstract semantics is given in the Appendix~\ref{appendix-ai-theory}.

\section{Semantics}

In Mathematics, the word \enquote{semantics} refers to the meaning of sentences in formal
languages \autocite{gunter_semantics_1992}. The semantics of programming languages
consist of what a piece of code means, how to interpret it, and how to analyse it.

\textcite{mitchell1996foundations}\todo{find a better reference} classifies programming
languages semantics into three categories: axiomatic semantics, denotational semantics,
and operational semantics. Axiomatic semantics are all about describing the behaviour of
code with mathematical logic. Denotational semantics goal is to find a mathematical
"object" that represents what a program does. The program's meaning is given by the
object properties or lack of thereof. Operational semantics are concerned with rules that
tell how to interpret or execute a piece of code. No meaning is given to the parts of the
program, but a meaning is given as the program is run.


\begin{verbatim}
  Semantics of Programming Languages
  |-- Axiomatic Semantics -- Hoare Logic
  |-- Denotational Semantics -- ???
  |-- Operational Semantics -- Small-step semantics
                           |-- Big-step semantics
\end{verbatim}

Notice that Denotational semantics must not provide a way to determine an implementation.
On the other hand, an implementation can be easily build from Operational Semantics.
Small-step semantics are define what the program does by describing a set of rules over
the syntax of the language. The meaning of the program is given by the application of the
rules. It is not a surprise that all efforts into defining formal semantics for Python
have been small-step semantics
\autocites{ranson_semantics_2008}{guth_formal_2013}{politz_python_2013}{fromherz_static_2018}.

Small-step semantics are also the closest in our work. Our purpose is to approximate the
value of variables on execution. For this, we will like to follow as closely as possible
the execution model of CPython, the official implementation of the Python language. First,
we will define the small-step semantics of a portion of Python, our concrete semantics
for the problem. Next, based on the concrete semantics, we will define one abstract
semantics for Python.

\section{Concrete Semantics of Python}

Before we define the concrete semantics of Python, we need to define how to write a piece
of code in Python. Python is a mature and large language, thus we will take just a portion
of it into account. In the figure below, we present the subset of Python that we intend to
study in this work.

\begin{verbatim}
expr = Int(i) for i \in \N | Float(j) for j \in floats
     | True | False | None

     | identifier         -- variable name

     | expr op expr       -- eg, a + 5
     | expr cmpop expr    -- eg, a < 5
     | expr(expr*)        -- Function calling

     | expr.identifier    -- Attribute access
     | expr[expr]         -- Not supported for Numpy Arrays :S
     | [expr*]            -- list
     | (expr*)            -- tuple

stmt = del expr           -- delete expression
      | expr = expr       -- assignment
      | expr op= expr     -- augmented assignment
      | expr: expr = expr -- type annotation
      | while expr: stmt+
      | if expr: stmt+
      | import alias+
      | from identifier import alias+
      | expr              -- An expression can be an statement

op = + | - | * | / | % | ** | << | >> | //
cmpop = < | <= | > | >=

alias = identifier | identifier as identifier

identifier = string  -- with some restrictions
\end{verbatim}

We intentionally leave out any details related on the spacing of Python, as our main focus
is the meaning of Python values and not how are blocks of statements defined in the
language.

For the syntax above we can define the following rules, the small-semantics of the
language:

\inlinetodo{copy and modify rules from the appendix to make this part simpler, they will
probably return}

Notice that to define these rules we need to define two values: a global scope and a heap.
We store values in the heap and point to them with the global scope function.

The meaning of our program is the function \verb+S[prog]+ of type \verb+State -> State+.
In this work we are interested on the values that result on the application of the fuction
\verb+S[prog]+ on a clean state, which is a state that has only builtin variables defined.
Statements modify the state of the program. Expressions also modify the state of the
program but they additionaly return a value, e.g. the expression \pycode+ls.pop()+ removes
the last element in the list \pycode+ls+ and returns it. Thus the type of the function
\verb+E[expr]+ is \verb+State -> State x Val+

Time to see the semantics in action. Let's consider the simple program:

\begin{pythoncode}
b = 2
a = b < 3
\end{pythoncode}

With our rules we can "execute" our example:

\inlinetodo{execution step by step of the program}

Defining the small-step semantics on the syntax presented before is inconvinient. To see
why it is inconvinient to work with the defined syntax, consider the statement delete. The
statement delete is able to not only remove values from the global scope, e.g \pycode+del
a+, but it can also delete elements from a list, e.g. \pycode+del ls[2]+ delets the third
element of a list \pycode+ls+. Notice that whatever is being deleted by \pycode+del+ is an
expression. In the examples, \pycode+a+ and \pycode+ls[2]+ are both expressions. Then,
what should the expression return to indicate a value and a position on an object?. It is
hard to know what to return in a case like \pycode+ls[2][0].val[1]+. We opted to follow
what CPython does. CPython extends the syntax to make expresions return a position in memory
or a value depending on how will they be used by the statements.

Our new syntax will be:

\begin{verbatim}
mod = Module(stmt* body)

expr = Int(n)
     | Float(n) | True | False | None
     | Name(identifier, expr_context)
     | BinOp(operator, expr, expr)
     | Compare(expr, cmpop, expr)
     | Call(expr, expr*)
     | Attribute(expr, identifier)
     -- No need for expr_context because no user made objects are allowed yet, thus
     -- modifying attributes is not necessary
     -- | Attribute(expr, identifier, expr_context)
     | Subscript(expr, expr, expr_context)  -- No arbitrary slice allowed yet
     | List(expr*)
     | Tuple(expr*) -- No expr_context for Tuple as `(a, b) = 1, 2` is not supported

stmt = Delete(expr+)
      | Assign(expr, expr)                -- a = 3
      | AugAssign(expr, operator, expr)   -- a += 3
      | AnnAssign(expr, expr, expr)       -- a: int = 3

      | While(expr, stmt+)
      | If(expr, stmt+, stmt*)

      | Import(alias+ names)
      | ImportFrom(identifier, alias+)

      | Expr(expr)

-- Indicates why are we looking up a variable, attribute or subscript
expr_context = Load | Store | Del

operator = Add | Sub | Mult | Div | Mod | Pow | LShift
             | RShift | FloorDiv

cmpop = Lt | LtE | Gt | GtE

-- import name with optional 'as' alias.
alias = (identifier, identifier?)
\end{verbatim}

Notice that this syntax has been directly taken from the CPython implementation
\autocite{van2007python}. The developer is not supposed to write in this new syntax, but
code written in this syntax is the result of the parser. The parser takes code written in
the first syntax and defines a proper context (Load, Store, or Del) for the expressions
\pycode+Name+ and \pycode+Subscript+. All other expressions are considered Load by default.

Accordingly, our concrete semantics change. First the state of a program is:

\inlinetodo{the state as defined in the appendix}

and the semantics per se:

\inlinetodo{show new semantics, same from above}
\inlinetodo{notice that if our program arrives to a \texttt{Execution Halt} the program,
  and these have increased in number in this new syntax}

Notice the complexity of the type of the functions has increased. Now an expression can
not only return a value but three other things. The value returned by the application of
an expression to the state is selected depending on the context it is called.

Same example as before with the new syntax and semantics:

\inlinetodo{example again}

\inlinetodo{add another example using a list that references itself and how that can be
represented as a graph. Much easier to understand}

\section{Abstract Semantics}

In this sections we will intuitively build an abstract domain for the state of the
language, and we will define the abstract semantics of the language.

\subsection{State Abstract Domain}

\inlinetodo{explain what is the proposed abstract domain for just primitive values in the
language}

Notice that it is not enough with the primitive values, we need a place where to put them.
Whe define the abstract state as \inlinetodo{add definition of the State abstract domain}

A throughout explanation of how was the whole AD can be seen in the appendix \todo{add
  ref}.

Remember the parts of an Abstract Domain, most importantly how to unite two different
states of a program.

\inlinetodo{explain with an example why is it important to unite two states of a program,
  an ifelse works just fine}

Now that we have defined our abstract state, we need to define the abstract semantics
(just like we defined our concrete semantics based on the state).

\subsection{The semantics}

We present the abstract semantics here, for a little bit more rigourus treatment of them
take a look at the appendix.

Defining the abstract semantics is quite straightforward:

\inlinetodo{show the new semantics}

\inlinetodo{Show an example of running a faulty program with these semantics, the example
  could be done using images as the last example in the previous section}

To make the abstract interpreter useful, in the implementation we took care of adding
checks at any needed place. For this, we log every time the program would die with the
concrete semantics now where they do not die because the abstract interpreter returns the
wild card value of Top.
