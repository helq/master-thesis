@article{abadi_tensorflow_2016,
	title = {{TensorFlow}: {Large}-{Scale} {Machine} {Learning} on {Heterogeneous} {Distributed} {Systems}},
	shorttitle = {{TensorFlow}},
	url = {http://arxiv.org/abs/1603.04467},
	abstract = {TensorFlow is an interface for expressing machine learning algorithms, and an implementation for executing such algorithms. A computation expressed using TensorFlow can be executed with little or no change on a wide variety of heterogeneous systems, ranging from mobile devices such as phones and tablets up to large-scale distributed systems of hundreds of machines and thousands of computational devices such as GPU cards. The system is flexible and can be used to express a wide variety of algorithms, including training and inference algorithms for deep neural network models, and it has been used for conducting research and for deploying machine learning systems into production across more than a dozen areas of computer science and other fields, including speech recognition, computer vision, robotics, information retrieval, natural language processing, geographic information extraction, and computational drug discovery. This paper describes the TensorFlow interface and an implementation of that interface that we have built at Google. The TensorFlow API and a reference implementation were released as an open-source package under the Apache 2.0 license in November, 2015 and are available at www.tensorflow.org.},
	urldate = {2017-10-11},
	journal = {arXiv:1603.04467 [cs]},
	author = {Abadi, Martín and Agarwal, Ashish and Barham, Paul and Brevdo, Eugene and Chen, Zhifeng and Citro, Craig and Corrado, Greg S. and Davis, Andy and Dean, Jeffrey and Devin, Matthieu and Ghemawat, Sanjay and Goodfellow, Ian and Harp, Andrew and Irving, Geoffrey and Isard, Michael and Jia, Yangqing and Jozefowicz, Rafal and Kaiser, Lukasz and Kudlur, Manjunath and Levenberg, Josh and Mane, Dan and Monga, Rajat and Moore, Sherry and Murray, Derek and Olah, Chris and Schuster, Mike and Shlens, Jonathon and Steiner, Benoit and Sutskever, Ilya and Talwar, Kunal and Tucker, Paul and Vanhoucke, Vincent and Vasudevan, Vijay and Viegas, Fernanda and Vinyals, Oriol and Warden, Pete and Wattenberg, Martin and Wicke, Martin and Yu, Yuan and Zheng, Xiaoqiang},
	month = mar,
	year = {2016},
	note = {arXiv: 1603.04467},
	keywords = {Computer Science - Learning, Computer Science - Distributed, Parallel, and Cluster Computing},
	file = {Abadi et al (2016) - TensorFlow.pdf:/home/helq/storage/Studies/Bibliography/Journal Article/Abadi et al (2016) - TensorFlow.pdf:application/pdf}
}

@article{rink_modeling_2018,
	title = {Modeling of languages for tensor manipulation},
	url = {http://arxiv.org/abs/1801.08771},
	abstract = {Numerical applications and, more recently, machine learning applications rely on high-dimensional data that is typically organized into multi-dimensional tensors. Many existing frameworks, libraries, and domain-specific languages support the development of efficient code for manipulating tensors and tensor expressions. However, such frameworks and languages that are used in practice often lack formal specifications. The present report formally defines a model language for expressing tensor operations. The model language is simple and yet general enough so that it captures the fundamental tensor operations common to most existing languages and frameworks. It is shown that the given formal semantics are sensible, in the sense that well-typed programs in the model language execute correctly, without error. Moreover, an alternative implementation of the model language is formally defined. The alternative implementation introduces padding into the storage of tensors, which may benefit performance on modern hardware platforms. Based on their formal definitions, the original implementation of the model language and the implementation with padding are proven equivalent. Finally, some possible extensions of the presented model language for tensor manipulation are discussed.},
	urldate = {2018-01-29},
	journal = {arXiv:1801.08771 [cs]},
	author = {Rink, Norman A.},
	month = jan,
	year = {2018},
	note = {arXiv: 1801.08771},
	keywords = {Computer Science - Programming Languages},
	file = {Rink (2018) - Modeling of languages for tensor manipulation.pdf:/home/helq/storage/Studies/Bibliography/Journal Article/Rink (2018) - Modeling of languages for tensor manipulation.pdf:application/pdf}
}

@article{chen_typesafe_2017,
	title = {Typesafe {Abstractions} for {Tensor} {Operations}},
	url = {http://arxiv.org/abs/1710.06892},
	doi = {10.1145/3136000.3136001},
	abstract = {We propose a typesafe abstraction to tensors (i.e. multidimensional arrays) exploiting the type-level programming capabilities of Scala through heterogeneous lists (HList), and showcase typesafe abstractions of common tensor operations and various neural layers such as convolution or recurrent neural networks. This abstraction could lay the foundation of future typesafe deep learning frameworks that runs on Scala/JVM.},
	urldate = {2018-02-19},
	journal = {arXiv:1710.06892 [cs]},
	author = {Chen, Tongfei},
	year = {2017},
	note = {arXiv: 1710.06892},
	keywords = {Computer Science - Programming Languages, D.3.2},
	pages = {45--50}
}

@inproceedings{eaton_statically_2006,
	title = {Statically typed linear algebra in {Haskell}},
	booktitle = {Proceedings of the 2006 {ACM} {SIGPLAN} workshop on {Haskell}},
	publisher = {ACM},
	author = {Eaton, Frederik},
	year = {2006},
	pages = {120--121},
	file = {Eaton (2006) - Statically typed linear algebra in Haskell.pdf:/home/helq/storage/Studies/Bibliography/Conference Paper/Eaton (2006) - Statically typed linear algebra in Haskell.pdf:application/pdf;Snapshot:/home/helq/.zoteroData/storage/B5IHH6NS/citation.html:text/html}
}

@book{oliphant2006guide,
  title={A guide to NumPy},
  author={Oliphant, Travis E},
  volume={1},
  year={2006},
  publisher={Trelgol Publishing USA},
  url={http://www.numpy.org/}
}

@misc{lehtosalo2016mypy,
  title={Mypy (2016)},
  author={Lehtosalo, Jukka and others},
  year={2016},
  url={http://mypy-lang.org/}
}

@inproceedings{bierman2014understanding,
  title={Understanding typescript},
  author={Bierman, Gavin and Abadi, Mart{\'\i}n and Torgersen, Mads},
  booktitle={European Conference on Object-Oriented Programming},
  pages={257--281},
  year={2014},
  organization={Springer}
}

@inproceedings{chaudhuri2016flow,
  title={Flow: Abstract interpretation of javascript for type checking and beyond},
  author={Chaudhuri, Avik},
  booktitle={Proceedings of the 2016 ACM Workshop on Programming Languages and Analysis for Security},
  pages={1--1},
  year={2016},
  organization={ACM}
}

@article{hejlsberg2012introducing,
  title={Introducing TypeScript},
  author={Hejlsberg, Anders},
  journal={Microsoft Channel},
  volume={9},
  year={2012}
}

@article{kazerounian_refinement_2017,
	title = {Refinement {Types} for {Ruby}},
	url = {http://arxiv.org/abs/1711.09281},
	abstract = {Refinement types are a popular way to specify and reason about key program properties. In this paper, we introduce RTR, a new system that adds refinement types to Ruby. RTR is built on top of RDL, a Ruby type checker that provides basic type information for the verification process. RTR works by encoding its verification problems into Rosette, a solver-aided host language. RTR handles mixins through assume-guarantee reasoning and uses just-in-time verification for metaprogramming. We formalize RTR by showing a translation from a core, Ruby-like language with refinement types into Rosette. We apply RTR to check a range of functional correctness properties on six Ruby programs. We find that RTR can successfully verify key methods in these programs, taking only a few minutes to perform verification.},
	urldate = {2017-12-02},
	journal = {arXiv:1711.09281 [cs]},
	author = {Kazerounian, Milod and Vazou, Niki and Bourgerie, Austin and Foster, Jeffrey S. and Torlak, Emina},
	month = nov,
	year = {2017},
	note = {arXiv: 1711.09281},
	keywords = {Computer Science - Programming Languages},
	file = {Kazerounian et al (2017) - Refinement Types for Ruby.pdf:/home/helq/storage/Studies/Bibliography/Journal Article/Kazerounian et al (2017) - Refinement Types for Ruby.pdf:application/pdf}
}

@inproceedings{siek_gradual_2006,
	title = {Gradual typing for functional languages},
	volume = {6},
	booktitle = {Scheme and {Functional} {Programming} {Workshop}},
	author = {Siek, Jeremy G. and Taha, Walid},
	year = {2006},
	pages = {81--92},
	file = {Fulltext:files/3805/Siek and Taha - 2006 - Gradual typing for functional languages.pdf:application/pdf;Siek_Taha (2006) - Gradual typing for functional languages.pdf:files/3804/Siek_Taha (2006) - Gradual typing for functional languages.pdf:application/pdf}
}

@misc{paszke2017pytorch,
  title={Pytorch},
  author={Paszke, Adam and Gross, Sam and Chintala, Soumith and Chanan, Gregory},
  year={2017}
}

@inproceedings{bergstra2011theano,
  title={Theano: Deep learning on gpus with python},
  author={Bergstra, James and Bastien, Fr{\'e}d{\'e}ric and Breuleux, Olivier and Lamblin, Pascal and Pascanu, Razvan and Delalleau, Olivier and Desjardins, Guillaume and Warde-Farley, David and Goodfellow, Ian and Bergeron, Arnaud and others},
  booktitle={NIPS 2011, BigLearning Workshop, Granada, Spain},
  volume={3},
  year={2011},
  organization={Citeseer}
}

@article{jia2014caffe,
  Author = {Jia, Yangqing and Shelhamer, Evan and Donahue, Jeff and Karayev, Sergey and Long, Jonathan and Girshick, Ross and Guadarrama, Sergio and Darrell, Trevor},
  Journal = {arXiv preprint arXiv:1408.5093},
  Title = {Caffe: Convolutional Architecture for Fast Feature Embedding},
  Year = {2014}
}

@phdthesis{cannon_localized_2005,
	type = {{PhD} {Thesis}},
	title = {Localized type inference of atomic types in python},
	school = {Citeseer},
	author = {Cannon, Brett},
	year = {2005},
	file = {Cannon (2005) - Localized type inference of atomic types in python.pdf:/home/helq/storage/Studies/Bibliography/Thesis/Cannon (2005) - Localized type inference of atomic types in python.pdf:application/pdf}
}

@inproceedings{gopinath_how_2017,
	title = {How {Good} {Are} {Your} {Types}? {Using} {Mutation} {Analysis} to {Evaluate} the {Effectiveness} of {Type} {Annotations}},
	shorttitle = {How {Good} {Are} {Your} {Types}?},
	doi = {10.1109/ICSTW.2017.28},
	abstract = {Software engineers primarily use two orthogonal means to reduce susceptibility to faults: software testing and static type checking. While many strategies exist to evaluate the effectiveness of a test suite in catching bugs, there are few that evaluate the effectiveness of type annotations in a program. This problem is most relevant in the context of gradual or optional typing, where programmers are free to choose which parts of a program to annotate and in what detail. Mutation analysis is one strategy that has proven useful for measuring test suite effectiveness by emulating potential software faults. We propose that mutation analysis can be used to evaluate the effectiveness of type annotations too. We analyze mutants produced by the MutPy mutation framework against both a test suite and against type-annotated programs. We show that, while mutation analysis can be useful for evaluating the effectiveness of type annotations, we require stronger mutation operators that target type information in programs to be an effective mutation analysis tool.},
	booktitle = {2017 {IEEE} {International} {Conference} on {Software} {Testing}, {Verification} and {Validation} {Workshops} ({ICSTW})},
	author = {Gopinath, R. and Walkingshaw, E.},
	month = mar,
	year = {2017},
	keywords = {Computer bugs, Context, Measurement, mutation analysis, mutation operators, MutPy mutation, program bugs, program debugging, program diagnostics, program testing, Servers, software faults, Software reliability, software testing, Software testing, static type checking, test suite effectiveness, type-annotated programs},
	pages = {122--127},
	file = {Gopinath_Walkingshaw (2017) - How Good Are Your Types.pdf:/home/helq/storage/Studies/Bibliography/Conference Paper/Gopinath_Walkingshaw (2017) - How Good Are Your Types.pdf:application/pdf}
}

@article{abe_simple_2015,
	title = {A {Simple} and {Practical} {Linear} {Algebra} {Library} {Interface} with {Static} {Size} {Checking}},
	url = {https://arxiv.org/abs/1512.01898},
	doi = {10.4204/EPTCS.198.1},
	language = {en},
	urldate = {2018-04-17},
	author = {Abe, Akinori and Sumii, Eijiro},
	month = dec,
	year = {2015},
	file = {Abe_Sumii (2015) - A Simple and Practical Linear Algebra Library Interface with Static Size.pdf:/home/helq/storage/Studies/Bibliography/Journal Article/Abe_Sumii (2015) - A Simple and Practical Linear Algebra Library Interface with Static Size.pdf:application/pdf}
}

@inproceedings{rakic_statically_2012,
	title = {Statically typed matrix: in {C}++ library},
	shorttitle = {Statically typed matrix},
	booktitle = {Proceedings of the {Fifth} {Balkan} {Conference} in {Informatics}},
	publisher = {ACM},
	author = {Rakić, Predrag S. and Stričević, Lazar and Rakić, Zorica Suvajdžin},
	year = {2012},
	pages = {217--222},
	file = {Rakic et al (2012) - Statically typed matrix.pdf:/home/helq/storage/Studies/Bibliography/Conference Paper/Rakic et al (2012) - Statically typed matrix.pdf:application/pdf;Snapshot:/home/helq/.zoteroData/storage/JBMK78VV/citation.html:text/html}
}

@misc{elkin_haskell_2018,
  author = {Cruz-Camacho, Elkin and Bowen, James},
  title = {tensorflow-haskell-deptyped: Reexporting TensorFlow Haskell with dependent typed functions},
  year = {2018},
  publisher = {GitHub},
  journal = {GitHub repository},
  howpublished = {\url{https://github.com/helq/tensorflow-haskell-deptyped}},
  commit = {91449866d6f5e26211963af3dd173930c4c93db8}
}

@article{trojahner_dependently_2009,
	series = {The 19th {Nordic} {Workshop} on {Programming} {Theory} ({NWPT} 2007)},
	title = {Dependently typed array programs don’t go wrong},
	volume = {78},
	issn = {1567-8326},
	url = {http://www.sciencedirect.com/science/article/pii/S1567832609000411},
	doi = {10.1016/j.jlap.2009.03.002},
	abstract = {The array programming paradigm adopts multidimensional arrays as the fundamental data structures of computation. Array operations process entire arrays instead of just single elements. This makes array programs highly expressive and introduces data parallelism in a natural way. Array programming imposes non-trivial structural constraints on ranks, shapes, and element values of arrays. A prominent example where such constraints are violated are out-of-bound array accesses. Usually, such constraints are enforced by means of run time checks. Both the run time overhead inflicted by dynamic constraint checking and the uncertainty of proper program evaluation are undesirable. We propose a novel type system for array programs based on dependent types. Our type system makes dynamic constraint checks obsolete and guarantees orderly evaluation of well-typed programs. We employ integer vectors of statically unknown length to index array types. We also show how constraints on these vectors are resolved using a suitable reduction to integer scalars. Our presentation is based on a functional array calculus that captures the essence of the paradigm without the legacy and obfuscation of a fully-fledged array programming language.},
	number = {7},
	urldate = {2018-04-17},
	journal = {The Journal of Logic and Algebraic Programming},
	author = {Trojahner, Kai and Grelck, Clemens},
	month = aug,
	year = {2009},
	keywords = {Array programming, Dependent types, Program verification},
	pages = {643--664},
	file = {Trojahner_Grelck (2009) - Dependently typed array programs don’t go wrong.pdf:/home/helq/storage/Studies/Bibliography/Journal Article/Trojahner_Grelck (2009) - Dependently typed array programs don’t go wrong.pdf:application/pdf}
}

@inproceedings{arnold_specifying_2010,
	address = {New York, NY, USA},
	series = {{ICFP} '10},
	title = {Specifying and {Verifying} {Sparse} {Matrix} {Codes}},
	isbn = {978-1-60558-794-3},
	url = {http://doi.acm.org/10.1145/1863543.1863581},
	doi = {10.1145/1863543.1863581},
	abstract = {Sparse matrix formats are typically implemented with low-level imperative programs. The optimized nature of these implementations hides the structural organization of the sparse format and complicates its verification. We define a variable-free functional language (LL) in which even advanced formats can be expressed naturally, as a pipeline-style composition of smaller construction steps. We translate LL programs to Isabelle/HOL and describe a proof system based on parametric predicates for tracking relationship between mathematical vectors and their concrete representations. This proof theory automatically verifies full functional correctness of many formats. We show that it is reusable and extensible to hierarchical sparse formats.},
	urldate = {2018-04-17},
	booktitle = {Proceedings of the 15th {ACM} {SIGPLAN} {International} {Conference} on {Functional} {Programming}},
	publisher = {ACM},
	author = {Arnold, Gilad and Hölzl, Johannes and Köksal, Ali Sinan and Bodík, Rastislav and Sagiv, Mooly},
	year = {2010},
	keywords = {verification, sparse matrix codes},
	pages = {249--260},
	file = {Arnold et al (2010) - Specifying and Verifying Sparse Matrix Codes.pdf:/home/helq/storage/Studies/Bibliography/Conference Paper/Arnold et al (2010) - Specifying and Verifying Sparse Matrix Codes.pdf:application/pdf}
}

@inproceedings{griffioen_type_2015,
	address = {New York, NY, USA},
	series = {{IFL} '15},
	title = {Type {Inference} for {Array} {Programming} with {Dimensioned} {Vector} {Spaces}},
	isbn = {978-1-4503-4273-5},
	url = {http://doi.acm.org/10.1145/2897336.2897341},
	doi = {10.1145/2897336.2897341},
	abstract = {Linear algebra operations are a typical application for array programming, but arrays are a more general data structure and not just used for numbers. This generality gives a lot of flexibility, but when numerical data structures like vectors and matrices are build from arrays, it is hard to infer properties like the shape statically, requiring costly out of bound checks to be done at runtime. We extend arrays with units of measurement, and Hindley-Milner typing with a matrix type based on the algebraic structure of units of measurement in matrices that allows type inference up to dimensioned vector spaces. The inference is sound and complete and gives the most general type of any linear algebra expression. Experiments show that the explicit support for linear algebra increases type safety, and that it leads to a more functional and index-free style of programming. It refines the types for linear algebra operators significantly, while the use of arrays as general containers has to be replaced by other data structures. As validation the matrix type system is implemented in the functional matrix language Pacioli.},
	urldate = {2018-04-17},
	booktitle = {Proceedings of the 27th {Symposium} on the {Implementation} and {Application} of {Functional} {Programming} {Languages}},
	publisher = {ACM},
	author = {Griffioen, P. R.},
	year = {2015},
	keywords = {linear algebra, matrix language, type inference, unit of measurement},
	pages = {4:1--4:12},
	file = {Griffioen (2015) - Type Inference for Array Programming with Dimensioned Vector Spaces.pdf:/home/helq/storage/Studies/Bibliography/Conference Paper/Griffioen (2015) - Type Inference for Array Programming with Dimensioned Vector Spaces.pdf:application/pdf}
}

@inproceedings{slepak_array-oriented_2014,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {An {Array}-{Oriented} {Language} with {Static} {Rank} {Polymorphism}},
	isbn = {978-3-642-54832-1},
	url = {https://link.springer.com/chapter/10.1007/978-3-642-54833-8_3},
	doi = {10.1007/978-3-642-54833-8_3},
	abstract = {The array-computational model pioneered by Iverson’s languages APL and J offers a simple and expressive solution to the “von Neumann bottleneck.” It includes a form of rank, or dimensional, polymorphism, which renders much of a program’s control structure implicit by lifting base operators to higher-dimensional array structures. We present the first formal semantics for this model, along with the first static type system that captures the full power of the core language.The formal dynamic semantics of our core language, Remora, illuminates several of the murkier corners of the model. This allows us to resolve some of the model’s ad hoc elements in more general, regular ways. Among these, we can generalise the model from SIMD to MIMD computations, by extending the semantics to permit functions to be lifted to higher-dimensional arrays in the same way as their arguments.Our static semantics, a dependent type system of carefully restricted power, is capable of describing array computations whose dimensions cannot be determined statically. The type-checking problem is decidable and the type system is accompanied by the usual soundness theorems. Our type system’s principal contribution is that it serves to extract the implicit control structure that provides so much of the language’s expressive power, making this structure explicitly apparent at compile time.},
	language = {en},
	urldate = {2018-04-17},
	booktitle = {Programming {Languages} and {Systems}},
	publisher = {Springer, Berlin, Heidelberg},
	author = {Slepak, Justin and Shivers, Olin and Manolios, Panagiotis},
	month = apr,
	year = {2014},
	pages = {27--46},
	file = {Slepak et al (2014) - An Array-Oriented Language with Static Rank Polymorphism - NOT FULL.pdf:/home/helq/storage/Studies/Bibliography/Conference Paper/Slepak et al (2014) - An Array-Oriented Language with Static Rank Polymorphism - NOT FULL.pdf:application/pdf;Slepak et al (2014) - An Array-Oriented Language with Static Rank Polymorphism.pdf:/home/helq/storage/Studies/Bibliography/Conference Paper/Slepak et al (2014) - An Array-Oriented Language with Static Rank Polymorphism.pdf:application/pdf}
}

@inproceedings{van2007python,
  title={Python Programming Language.},
  author={Van Rossum, Guido and others},
  booktitle={USENIX Annual Technical Conference},
  volume={41},
  pages={36},
  year={2007}
}

@inproceedings{ortin_towards_2015,
	title = {Towards a static type checker for python},
	volume = {15},
	booktitle = {European {Conference} on {Object}-{Oriented} {Programming} ({ECOOP}), {Scripts} to {Programs} {Workshop}, {STOP}},
	author = {Ortin, Francisco and Perez-Schofield, J. Baltasar G. and Redondo, Jose M.},
	year = {2015},
	pages = {1--2},
	file = {Ortin et al (2015) - Towards a static type checker for python.pdf:/home/helq/storage/Studies/Bibliography/Conference Paper/Ortin et al (2015) - Towards a static type checker for python.pdf:application/pdf}
}

@inproceedings{an_dynamic_2011,
	address = {New York, NY, USA},
	series = {{POPL} '11},
	title = {Dynamic {Inference} of {Static} {Types} for {Ruby}},
	isbn = {978-1-4503-0490-0},
	url = {http://doi.acm.org/10.1145/1926385.1926437},
	doi = {10.1145/1926385.1926437},
	abstract = {There have been several efforts to bring static type inference to object-oriented dynamic languages such as Ruby, Python, and Perl. In our experience, however, such type inference systems are extremely difficult to develop, because dynamic languages are typically complex, poorly specified, and include features, such as eval and reflection, that are hard to analyze. In this paper, we introduce constraint-based dynamic type inference, a technique that infers static types based on dynamic program executions. In our approach, we wrap each run-time value to associate it with a type variable, and the wrapper generates constraints on this type variable when the wrapped value is used. This technique avoids many of the often overly conservative approximations of static tools, as constraints are generated based on how values are used during actual program runs. Using wrappers is also easy to implement, since we need only write a constraint resolution algorithm and a transformation to introduce the wrappers. The best part is that we can eat our cake, too: our algorithm will infer sound types as long as it observes every path through each method body---note that the number of such paths may be dramatically smaller than the number of paths through the program as a whole. We have developed Rubydust, an implementation of our algorithm for Ruby. Rubydust takes advantage of Ruby's dynamic features to implement wrappers as a language library. We applied Rubydust to a number of small programs and found it to be both easy to use and useful: Rubydust discovered 1 real type error, and all other inferred types were correct and readable.},
	urldate = {2018-05-21},
	booktitle = {Proceedings of the 38th {Annual} {ACM} {SIGPLAN}-{SIGACT} {Symposium} on {Principles} of {Programming} {Languages}},
	publisher = {ACM},
	author = {An, Jong-hoon (David) and Chaudhuri, Avik and Foster, Jeffrey S. and Hicks, Michael},
	year = {2011},
	keywords = {dynamic languages, dynamic type inference, ruby, static types},
	pages = {459--472}
}

@Misc{pyflakes2005,
  author =    {A lot of people},
  title =     {{Pyflakes}: A simple program which checks {Python} source files for errors},
  year =      {2005--},
  url = {"https://pypi.org/project/pyflakes/"},
  note = {[Online; accessed May 21 2018]}
}

@misc{thenaultpylint,
  title={Pylint -- Code Analysis for Python},
  author={Thenault, Sylvain and others},
  year={2006--},
  url={https://pylint.org/},
  note={[Online; accessed May 21 2018]}
}

@misc{norwitzpychecker,
  title={PyChecker},
  author={Norwitz, Neal},
  journal={SourceForge project},
  url={http://pychecker.sourceforge.net}
}

@misc{jetbrainsweb,
  title={for Web Developers: JetBrains PyCharm, 2015},
  author={JETBRAINS, Python IDE and Django, IDE}
}

@book{pierce_types_2002,
	title = {Types and programming languages},
	publisher = {MIT press},
	author = {Pierce, Benjamin C and Benjamin, C},
	year = {2002}
}

@inproceedings{politz_python_2013,
	title = {Python: the full monty},
	volume = {48},
	shorttitle = {Python},
	booktitle = {{ACM} {SIGPLAN} {Notices}},
	publisher = {ACM},
	author = {Politz, Joe Gibbs and Martinez, Alejandro and Milano, Matthew and Warren, Sumner and Patterson, Daniel and Li, Junsong and Chitipothu, Anand and Krishnamurthi, Shriram},
	year = {2013},
	pages = {217--232},
	file = {Politz et al (2013) - Python.pdf:/home/helq/storage/Studies/Bibliography/Conference Paper/Politz et al (2013) - Python.pdf:application/pdf;Snapshot:/home/helq/.zoteroData/storage/UKRCXALN/citation.html:text/html}
}

@misc{python_software_foundation_python_2019,
	title = {The {Python} {Language} {Reference} — {Python} 3.6.8 documentation},
	url = {https://docs.python.org/3.6/reference/},
	urldate = {2019-02-12},
	author = {Python Software Foundation},
	month = feb,
	year = {2019}
}

@inproceedings{fromherz_static_2018,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Static {Value} {Analysis} of {Python} {Programs} by {Abstract} {Interpretation}},
	isbn = {978-3-319-77935-5},
	abstract = {We propose a static analysis by abstract interpretation for a significant subset of Python to infer variable values, run-time errors, and uncaught exceptions. Python is a high-level language with dynamic typing, a class-based object system, complex control structures such as generators, and a large library of builtin objects. This makes static reasoning on Python programs challenging. The control flow is highly dependent on the type of values, which we thus infer accurately.As Python lacks a formal specification, we first present a concrete collecting semantics of reachable program states. We then propose a non-relational flow-sensitive type and value analysis based on simple abstract domains for each type, and handle non-local control such as exceptions through continuations. We show how to infer relational numeric invariants by leveraging the type information we gather. Finally, we propose a relational abstraction of generators to count the number of available elements and prove that no StopIteration exception is raised.Our prototype implementation is heavily in development; it does not support some Python features, such as recursion nor the compile builtin, and it handles only a small part of the builtin objects and standard library. Nevertheless, we are able to present preliminary experimental results on analyzing actual, if small, Python code from a benchmarking application and a regression test suite.},
	language = {en},
	booktitle = {{NASA} {Formal} {Methods}},
	publisher = {Springer International Publishing},
	author = {Fromherz, Aymeric and Ouadjaout, Abdelraouf and Miné, Antoine},
	editor = {Dutle, Aaron and Muñoz, César and Narkawicz, Anthony},
	year = {2018},
	pages = {185--202},
	file = {Fromherz et al (2018) - Static Value Analysis of Python Programs by Abstract Interpretation.pdf:/home/helq/storage/Studies/Bibliography/Conference Paper/Fromherz et al (2018) - Static Value Analysis of Python Programs by Abstract Interpretation.pdf:application/pdf}
}

@article{guth_formal_2013,
	title = {A formal semantics of {Python} 3.3},
	author = {Guth, Dwight},
	year = {2013},
	file = {Guth (2013) - A formal semantics of Python 3.pdf:/home/helq/storage/Studies/Bibliography/Journal Article/Guth (2013) - A formal semantics of Python 3.pdf:application/pdf}
}

@techreport{monat_static_2018,
	type = {Intership report},
	title = {Static {Analysis} by {Abstract} {Interpretation} {Collecting} {Types} of {Python} {Programs}},
	url = {https://hal.archives-ouvertes.fr/hal-01869049},
	abstract = {Software bugs are costly: they can have disastrous consequences on critical systems, but also on more common applications such as Web servers. It is thus interesting to possess tools helping developers detect those bugs before they ship software into production. 

The most common approach to avoid those errors is to use testing, which is inefficient: tests are usually written by hand, taking time, and they cover a few executions of a program, but not all of them. 

The approach I undertook during this internship is to design a static analyzer by abstract interpretation for Python. Static analyzers are programs that automatically analyze an input program and report errors this input program may contain (given a certain class of errors the static analyzer may detect). In particular, if a static analyzer is sound and reports no error on a given input, we know that this program does not contain any error from the class the static analyzer is able to discover. Abstract interpretation is a theory formalizing links between a precise but costly semantics with some computable, approximated counterpart, thus guiding the design and implementation of sound static analyzers.

State of the art static analyzers include Julia (analyzing Java), Astrée and Sparrow (for C software). Those are only analyzing statically typed languages. There are no mature static analyzers available for dynamic languages such as JavaScript and Python, although a few static analyses have already been developed and implemented.

During this internship, I developed a static analysis of Python programs collecting the types of each variable, and possible type error exceptions. 
 Python is a popular programming language, especially used in teaching and in the scientific community, well-known for its powerful syntax. Major software projects written in Python include the Django web framework and the SageMath computer algebra system. Python is an object-oriented dynamic language, where every value is an object. Python's dynamism means that undeclared variables, type incompatibilities, {\textbackslash}dots{\textbackslash}, are exceptions detected at runtime.},
	urldate = {2019-02-12},
	institution = {LIP6 - Laboratoire d'Informatique de Paris 6},
	author = {Monat, Raphaël},
	month = sep,
	year = {2018},
	keywords = {Python, Abstract interpretation, Python programming language, Static analysis, Static analysis by abstract interpretation, Type analysis},
	file = {Monat (2018) - Static Analysis by Abstract Interpretation Collecting Types of Python Programs.pdf:/home/helq/storage/Studies/Bibliography/Report/Monat (2018) - Static Analysis by Abstract Interpretation Collecting Types of Python Programs.pdf:application/pdf}
}

@article{ranson_semantics_2008,
	title = {A {Semantics} of {Python} in {Isabelle}/{HOL}},
	author = {Ranson, James F. and Hamilton, Howard J. and Fong, Philip WL and Hamilton, H. J. and Fong, P. W. L.},
	year = {2008},
	file = {Ranson et al (2008) - A Semantics of Python in Isabelle-HOL.pdf:/home/helq/storage/Studies/Bibliography/Journal Article/Ranson et al (2008) - A Semantics of Python in Isabelle-HOL.pdf:application/pdf}
}

@inproceedings{cousot_abstract_1977,
	address = {New York, NY, USA},
	series = {{POPL} '77},
	title = {Abstract {Interpretation}: {A} {Unified} {Lattice} {Model} for {Static} {Analysis} of {Programs} by {Construction} or {Approximation} of {Fixpoints}},
	shorttitle = {Abstract {Interpretation}},
	url = {http://doi.acm.org/10.1145/512950.512973},
	doi = {10.1145/512950.512973},
	abstract = {A program denotes computations in some universe of objects. Abstract interpretation of programs consists in using that denotation to describe computations in another universe of abstract objects, so that the results of abstract execution give some information on the actual computations. An intuitive example (which we borrow from Sintzoff [72]) is the rule of signs. The text -1515 * 17 may be understood to denote computations on the abstract universe \{(+), (-), (±)\} where the semantics of arithmetic operators is defined by the rule of signs. The abstract execution -1515 * 17 → -(+) * (+) → (-) * (+) → (-), proves that -1515 * 17 is a negative number. Abstract interpretation is concerned by a particular underlying structure of the usual universe of computations (the sign, in our example). It gives a summary of some facets of the actual executions of a program. In general this summary is simple to obtain but inaccurate (e.g. -1515 + 17 → -(+) + (+) → (-) + (+) → (±)). Despite its fundamentally incomplete results abstract interpretation allows the programmer or the compiler to answer questions which do not need full knowledge of program executions or which tolerate an imprecise answer, (e.g. partial correctness proofs of programs ignoring the termination problems, type checking, program optimizations which are not carried in the absence of certainty about their feasibility, …).},
	urldate = {2018-07-26},
	booktitle = {Proceedings of the 4th {ACM} {SIGACT}-{SIGPLAN} {Symposium} on {Principles} of {Programming} {Languages}},
	publisher = {ACM},
	author = {Cousot, Patrick and Cousot, Radhia},
	year = {1977},
	pages = {238--252},
	file = {Cousot_Cousot (1977) - Abstract Interpretation.pdf:/home/helq/storage/Studies/Bibliography/Conference Paper/Cousot_Cousot (1977) - Abstract Interpretation.pdf:application/pdf}
}

@phdthesis{urban_static_2015,
	type = {phdthesis},
	title = {Static analysis by abstract interpretation of functional temporal properties of programs},
	url = {https://tel.archives-ouvertes.fr/tel-01176641/document},
	abstract = {The overall aim of this thesis is the development of mathematically sound and practically efficient methods for automatically proving the correctness of computer software. More specifically, this thesis is grounded in the theory of abstract interpretation, a powerful mathematical framework for approximating the behavior of programs. In particular, this thesis focuses on provingprogram liveness properties, which represent requirements that must be eventually or repeatedly realized during program execution. Program termination is the most prominent liveness property. This thesis designs new program approximations, in order to automatically infer sufficient preconditions for program termination and synthesize so called piecewisedefined ranking functions, which provide upper bounds on the waiting time before termination. The approximations are parametric in the choice between the expressivity and the cost of the underlying approximations, which maintain information about the set of possible values of the program variables along with the possible numerical relationships between them. This thesis also contributes an abstract interpretation framework for proving liveness properties, which comes as a generalization of the framework proposedfor termination. In particular, the framework is dedicated to liveness properties expressed in temporal logic, which are used to ensure that some desirable event happens once or infinitely many times during program execution. As for program termination, piecewise-defined ranking functions are used to infer sufficient preconditions for these properties, and to provide upper boundson the waiting time before a desirable event. The results presented in this thesis have been implemented into a prototype analyzer. Experimental results show that it performs well on a wide variety of benchmarks, it is competitive with the state of the art, and is able to analyze programs that are out of the reach of existing methods.},
	language = {en},
	urldate = {2018-07-25},
	school = {Ecole normale supérieure - ENS PARIS},
	author = {Urban, Caterina},
	month = jul,
	year = {2015},
	file = {Urban (2015) - Static analysis by abstract interpretation of functional temporal properties of.pdf:/home/helq/storage/Studies/Bibliography/Thesis/Urban (2015) - Static analysis by abstract interpretation of functional temporal properties of.pdf:application/pdf}
}

@book{nielson2015principles,
  title={Principles of program analysis},
  author={Nielson, Flemming and Nielson, Hanne R and Hankin, Chris},
  year={2015},
  publisher={Springer}
}

@incollection{nipkow_abstract_2014,
	address = {Cham},
	title = {Abstract {Interpretation}},
	isbn = {978-3-319-10542-0},
	url = {https://doi.org/10.1007/978-3-319-10542-0_13},
	abstract = {In Chapter 10 we saw a number of automatic program analyses, and each one was hand crafted. Abstract Interpretation is a generic approach to automatic program analysis. In principle, it covers all of our earlier analyses. In this chapter we ignore the optimizing program transformations that accompany certain analyses.},
	language = {en},
	urldate = {2019-02-23},
	booktitle = {Concrete {Semantics}: {With} {Isabelle}/{HOL}},
	publisher = {Springer International Publishing},
	author = {Nipkow, Tobias and Klein, Gerwin},
	editor = {Nipkow, Tobias and Klein, Gerwin},
	year = {2014},
	doi = {10.1007/978-3-319-10542-0_13},
	keywords = {Abstract Interpretation, Boolean Expression, Complete Lattice, Monotone Function, Partial Order},
	pages = {219--280}
}

@article{lauko_symbolic_2018,
	title = {Symbolic {Computation} via {Program} {Transformation}},
	url = {http://arxiv.org/abs/1806.03959},
	abstract = {Symbolic computation is an important approach in automated program analysis. Most state-of-the-art tools perform symbolic computation as interpreters and directly maintain symbolic data. In this paper, we show that it is feasible, and in fact practical, to use a compiler-based strategy instead. Using compiler tooling, we propose and implement a transformation which takes a standard program and outputs a program that performs semantically equivalent, but partially symbolic, computation. The transformed program maintains symbolic values internally and operates directly on them hence the program can be processed by a tool without support for symbolic manipulation. The main motivation for the transformation is in symbolic verification, but there are many other possible use-cases, including test generation and concolic testing. Moreover using the transformation simplifies tools, since the symbolic computation is handled by the program directly. We have implemented the transformation at the level of LLVM bitcode. The paper includes an experimental evaluation, based on an explicit-state software model checker as a verification backend.},
	urldate = {2018-06-26},
	journal = {arXiv:1806.03959 [cs]},
	author = {Lauko, Henrich and Ročkai, Petr and Barnat, Jiří},
	month = may,
	year = {2018},
	note = {arXiv: 1806.03959},
	keywords = {Computer Science - Programming Languages},
	file = {Lauko et al (2018) - Symbolic Computation via Program Transformation.pdf:/home/helq/storage/Studies/Bibliography/Journal Article/Lauko et al (2018) - Symbolic Computation via Program Transformation.pdf:application/pdf}
}

@misc{pep484,
	title = {{PEP} 484 -- {Type} {Hints}},
	url = {https://www.python.org/dev/peps/pep-0484/},
	abstract = {The official home of the Python Programming Language},
	language = {en},
	urldate = {2019-02-27},
	journal = {Python.org},
	author = {{Guido van Rossum} and {Jukka Lehtosalo} and {Łukasz Langa}},
	month = sep,
	year = {2014}
}

@misc{pep526,
	title = {{PEP} 526 -- {Syntax} for {Variable} {Annotations}},
	url = {https://www.python.org/dev/peps/pep-0526/},
	abstract = {The official home of the Python Programming Language},
	language = {en},
	urldate = {2019-02-27},
	journal = {Python.org},
	author = {{Ryan Gonzalez} and {Philip House} and {Ivan Levkivskyi} and {Lisa Roach} and {Guido van Rossum}},
	month = aug,
	year = {2016}
}

@misc{pep483,
	title = {{PEP} 483 -- {The} {Theory} of {Type} {Hints}},
	url = {https://www.python.org/dev/peps/pep-0483/},
	abstract = {The official home of the Python Programming Language},
	language = {en},
	urldate = {2019-02-27},
	journal = {Python.org},
	author = {{Guido van Rossum} and {Ivan Levkivskyi}},
	month = dec,
	year = {2014}
}

@article{rushby_subtypes_1998,
	title = {Subtypes for specifications: {Predicate} subtyping in {PVS}},
	volume = {24},
	shorttitle = {Subtypes for specifications},
	number = {9},
	journal = {IEEE Transactions on Software Engineering},
	author = {Rushby, John and Owre, Sam and Shankar, Natarajan},
	year = {1998},
	pages = {709--720}
}

@article{eisenberg_dependent_2016,
	title = {Dependent types in {Haskell}: {Theory} and practice},
	shorttitle = {Dependent types in {Haskell}},
	url = {https://arxiv.org/abs/1610.07978},
	urldate = {2017-07-18},
	journal = {arXiv preprint arXiv:1610.07978},
	author = {Eisenberg, Richard A.},
	year = {2016},
	file = {Eisenberg (2016) - Dependent types in Haskell.pdf:/home/helq/storage/Studies/Bibliography//Journal Article/Eisenberg (2016) - Dependent types in Haskell.pdf:application/pdf}
}

@misc{krekel_pypy_2007,
  title = {IST FP6-004779 PYPY - Final Activity Report},
  author = {{Holger Krekel} and {Lene Wagner} and {Jacob Hallén} and {Beatrice During} and
          {Carl Friedrich Bolz} and {Laura Creighton} and {Armin Rigo} and
          {Michael Hudson} and {Samuele Pedroni} and {Christian Tismer} and {Alexandre Fayolle}
          and {Maciej Fijalkowski}},
  year = 2007,
  month = may,
  url = {http://doc.pypy.org/en/latest/index-report.html},
  publisher={Technical report, PyPy Consortium},
}

@phdthesis{mine_weakly_2004,
	type = {{PhD} {Thesis}},
	title = {Weakly relational numerical abstract domains},
	school = {Ecole Polytechnique X},
	author = {Miné, Antoine},
	year = {2004},
	file = {Mine (2004) - Weakly relational numerical abstract domains.pdf:/home/helq/storage/Studies/Bibliography/Thesis/Mine (2004) - Weakly relational numerical abstract domains.pdf:application/pdf}
}
