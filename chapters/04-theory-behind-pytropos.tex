\chapter{Abstract Interpretation for Python}\label{ai-for-python}

In this chapter, an Abstract Interpreter for Python is proposed. The chapter is divided
into five parts: what are semantics, concrete semantics for Value Analysis of Python code,
abstract semantics, extension to work with NumPy arrays, and the abstract semantics of
type annotations. This chapter is intended as a guide on how was the Abstract Interpreter
built and why was it built the way it is. A deeper look on the gory details of the
concrete and abstract semantics is given in the Appendix~\ref{appendix-ai-theory}.

\section{Semantics}

In Mathematics, the word \enquote{semantics} refers to the meaning of sentences in formal
languages \autocite{gunter_semantics_1992}. The semantics of programming languages
consist of what a piece of code means, how to interpret it, and how to analyse it.

\textcite{mitchell1996foundations}\todo{find a better reference} classifies programming
languages semantics into three categories: axiomatic semantics, denotational semantics,
and operational semantics. Axiomatic semantics are all about describing the behaviour of
code with mathematical logic. Denotational semantics goal is to find a mathematical
"object" that represents what a program does. The program's meaning is given by the
object properties or lack of thereof. Operational semantics are concerned with rules that
tell how to interpret or execute a piece of code. No meaning is given to the parts of the
program, but a meaning is given as the program is run.


\begin{verbatim}
  Semantics of Programming Languages
  |-- Axiomatic Semantics -- Hoare Logic
  |-- Denotational Semantics -- ???
  |-- Operational Semantics -- Small-step semantics
                           |-- Big-step semantics
\end{verbatim}

Notice that Denotational semantics must not provide a way to determine an implementation.
On the other hand, an implementation can be easily build from Operational Semantics.
Small-step semantics are define what the program does by describing a set of rules over
the syntax of the language. The meaning of the program is given by the application of the
rules. It is not a surprise that all efforts into defining formal semantics for Python
have been small-step semantics
\autocites{ranson_semantics_2008}{guth_formal_2013}{politz_python_2013}{fromherz_static_2018}.

Small-step semantics are also the closest in our work. Our purpose is to approximate the
value of variables on execution. For this, we will like to follow as closely as possible
the execution model of CPython, the official implementation of the Python language. First,
we will define the small-step semantics of a portion of Python, our concrete semantics
for the problem. Next, based on the concrete semantics, we will define one abstract
semantics for Python.

\section{Concrete Semantics of Python}

Before we define the concrete semantics of Python, we need to define how to write a piece
of code in Python. Python is a mature and large language, thus we will take just a portion
of it into account. In the figure below, we present the subset of Python that we intend to
study in this work.

\begin{verbatim}
expr = Int(i) for i \in \N | Float(j) for j \in floats
     | True | False | None

     | identifier         -- variable name

     | expr op expr       -- eg, a + 5
     | expr cmpop expr    -- eg, a < 5
     | expr(expr*)        -- Function calling

     | expr.identifier    -- Attribute access
     | expr[expr]         -- Not supported for Numpy Arrays :S
     | [expr*]            -- list
     | (expr*)            -- tuple

stmt = del expr           -- delete expression
      | expr = expr       -- assignment
      | expr op= expr     -- augmented assignment
      | expr: expr = expr -- type annotation
      | while expr: stmt+
      | if expr: stmt+
      | import alias+
      | from identifier import alias+
      | expr              -- An expression can be an statement

op = + | - | * | / | % | ** | << | >> | //
cmpop = < | <= | > | >=

alias = identifier | identifier as identifier

identifier = string  -- with some restrictions
\end{verbatim}

We intentionally leave out any details related on the spacing of Python, as our main focus
is the meaning of Python values and not how are blocks of statements defined in the
language.

Python memory is represented as a function memory positions to values. The global scope is
defined as a function from identifiers to memory positions.

\begin{verbatim}
Global = Iden -> Addr + Undefined   -- Global scope
Heap = Addr -> Val + Undefined      -- Heap
\end{verbatim}

In Python everything is an object: numbers, lists, classes and even functions. We separate
values into three categories: primitive values, like numbers, booleans and \pycode+None+;
\verb+Object+s, like lists and tuples; and, primitive functions, like
\pycode+int.__add__+.

\begin{verbatim}
Val = PrimVal | Object | <prim-callable>
PrimVal = ints... | floats... | True | False | None | Undefined

Object = Type x Addr x (Key -> Addr + Undefined)
Type = List | Tuple
Key = Iden + (string x Val)
\end{verbatim}

We can now define the rules that describe the behaviour of a program, the small-semantics
of the language.

\begin{verbatim}
E[expr] : Global x Heap -> Global x Heap x Val

E[identifier](G, H) :=
    if G(id) = Undefined
    then <Execution Halt>
    else (G, H, H(G(id)))

-- n is a number
E[n](G, H) := (G, H, n)

E[expr1 op expr2](G, H) :=
    let (G1, H1, v1) := E[expr1](G, H)
        (G2, H2, v2) := E[expr2](G1, H1)
        prim_op := get_prim_op(op, v1, v2)
     in prim_op(G2, H2)

get_prim_op : string x Val x Val -> Global x Heap -> Global x Heap x Addr
get_prim_op(op, v1, v2) :=
  match (type(v1), type(v2)) in
    case (int, int) -> \(G, H) -> <prim-+-int>(v1, v2, G, H)
    case (float, float) -> \(G, H) -> <prim-+-float>(v1, v2, G, H)
    case (int, bool) -> \(G, H)-> <prim-+-int>(v1, to_int(v2), G, H)
    case (bool, int) -> \(G, H)-> <prim-+-int>(to_int(v1), v2, G, H)
    case (float, a) -> if a = Bool or a = Int
                       then \(G, H)-> <prim-+-float>(v1, to_float(v2), G, H)
                       else <Execution Halt>
    case (a, float) -> if a = Bool or a = Int
                       then \(G, H)-> <prim-+-float>(to_float(v1), v2, G, H)
                       else <Execution Halt>
    -- This function is to be extended once we add NdArrays to the mix
    case otherwise -> <Execution Halt>

<prim-+-int> : Val x Val x Global x Heap -> Global x Heap x Val
<prim-+-int>(i, j, G, H) := (G, H, i+j)

get_free_addr : Heap -> Addr
get_free_addr(H) := max({ad in H | H(ad) != Undefined}, -1) + 1

S[stmt] : Global x Heap -> Global x Heap

-- semantics of a sequence of statements
S[stmt1; stmts](G, H) :=
  let (G1, H1) := S[stmt1](G, H)
   in S[stmts](G1, H1)

S[identifier = expr](G, H) :=
  let (G1, H1, val) := E[expr](G, H)
      adnew := get_free_addr(H1)
   in (G1[identifier->adnew], H1[adnew->val])

Gempty : Global
Gempty(x) := Undefined

Hempty : Heap
Hempty(x) := Undefined
\end{verbatim}

The construction \verb+<Execution Halt>+ indicates that the interpreter cannot go any
further. For example, accessing to a variable that has not yet been defined is considered
an error, in fact, Python will throw an exception if this happens.

The meaning of our program is the function \verb+S[prog]+ of type \verb+State -> State+
(where \verb|State = Global x Heap|).
In this work we are interested on the values that result on the application of the fuction
\verb+S[prog]+ on a clean state, which is a state that has only builtin variables defined.
Statements modify the state of the program. Expressions also modify the state of the
program but they additionaly return a value, e.g. the expression \pycode+ls.pop()+ removes
the last element in the list \pycode+ls+ and returns it. Thus the type of the function
\verb+E[expr]+ is \verb+State -> State x Val+

Time to see the semantics in action. Let's consider the simple program:

\begin{pythoncode}
b = 2
a = b + 3
\end{pythoncode}

We can apply the semantics rules on the example by evaluating
\verb|S[b = 2; a = b + 3](Gempty, Hempty)|. Step by step:

\begin{verbatim}
S[b = 2; a = b + 3](Gempty, Hempty)
   (def)= let (G1, H1) := S[b = 2](Gempty, Hempty)
           in S[a = b + 3](G1, H1)

>  S[b = 2](Gempty, Hempty)
>    (def)= let (G1, H1, val) := E[2](Gempty, Hempty)
>               adnew := get_free_addr(H)
>            in (G1[b->adnew], H1[adnew->val])
>    (def)= let (G1, H1, val) := (Gempty, Hempty, 2)
>               adnew := get_free_addr(H)
>            in (G1[b->adnew], H1[adnew->2])
>         = let adnew := get_free_addr(H)
>            in (G1[b->adnew], H1[adnew->2])
>         = let adnew := 0
>            in (G1[b->adnew], H1[adnew->2])
>         = (Gempty[b->0], Hempty[0->2])
>         = ({b->0}, {0->2})  -- simplifying notation

        = let (G1, H1) := ({b->0}, {0->2})
           in S[a = b + 3](G1, H1)
        = S[a = b + 3]({b->0}, {0->2})
   (def)= let (G1, H1, val) := E[b + 3]({b->0}, {0->2})
              adnew := get_free_addr(H)
           in (G1[a->adnew], H1[adnew->val])

>  E[b + 3]({b->0}, {0->2})
>    (def)= let (G1, H1, v1) := E[b]({b->0}, {0->2})
>               (G2, H2, v2) := E[3](G1, H1)
>               prim_op := get_prim_op(+, v1, v2)
>            in prim_op(G2, H2)

>>  E[b]({b->0}, {0->2})
>>     (def)= if {b->0}(b) = Undefined
>>            then <Execution Halt>
>>            else (G, H, H(G(b)))
>>          = ({b->0}, {0->2}, {0->2}({b->0}(b)))
>>          = ({b->0}, {0->2}, {0->2}(0))
>>          = ({b->0}, {0->2}, 2)

>         = let (G1, H1, v1) := ({b->0}, {0->2}, 2)
>               (G2, H2, v2) := E[3](G1, H1)
>               prim_op := get_prim_op(+, v1, v2)
>            in prim_op(G2, H2)
>         = let (G2, H2, v2) := E[3]({b->0}, {0->2})
>               prim_op := get_prim_op(+, 2, v2)
>            in prim_op(G2, H2)
>         = let (G2, H2, v2) := ({b->0}, {0->2}, 3)
>               prim_op := get_prim_op(+, 2, v2)
>            in prim_op(G2, H2)
>         = let prim_op := get_prim_op(+, 2, 3)
>            in prim_op({b->0}, {0->2})
>         = ... jumping a couple of transitions
>         = <prim-+-int>(2, 3, {b->0}, {0->2})
>         = ({b->0}, {0->2}, 5)

        = let (G1, H1, val) := ({b->0}, {0->2}, 5)
              adnew := get_free_addr(H)
           in (G1[a->adnew], H1[adnew->5])
        = let adnew := get_free_addr({0->2})
           in ({b->0}[a->adnew], {0->2}[adnew->5])
        = let adnew := 1
           in ({b->0}[a->adnew], {0->2}[adnew->5])
        = ({b->0}[a->1], {0->2}[1->5])
        = ({b->0, a->1}, {0->2, 1->5}) -- end of execution
\end{verbatim}

At the end of the execution, we know that the state result of executing the example code
is \verb|(G, H)|, where:

\begin{verbatim}
  G : Iden -> Addr
  b -> 0
  a -> 1

  H : Addr -> Val
  0 -> 2
  1 -> 5
\end{verbatim}

Which is telling us that the variables \pycode+a+ and \pycode+b+ hold the values
\pycode+2+ and \pycode+5+, respectively.

Notice that we have not yet defined the semantics of \verb+S[expr1 = expr2]+.
Defining the small-step semantics on the syntax presented before is inconvinient. To see
why it is inconvinient to work with the defined syntax, consider the statement delete. The
statement delete is able to not only remove values from the global scope, e.g \pycode+del
a+, but it can also delete elements from a list, e.g. \pycode+del ls[2]+ delets the third
element of a list \pycode+ls+. Notice that whatever is being deleted by \pycode+del+ is an
expression. In the examples, \pycode+a+ and \pycode+ls[2]+ are both expressions. Then,
what should the expression return to indicate a value and a position on an object?. It is
hard to know what to return in a case like \pycode+ls[2][0].val[1]+. We opted to follow
what CPython does. CPython extends the syntax to make expresions return a position in memory
or a value depending on how will they be used by the statements.

Our new syntax will be:

\begin{verbatim}
mod = Module(stmt* body)

expr = Int(n)
     | Float(n) | True | False | None
     | Name(identifier, expr_context)
     | BinOp(operator, expr, expr)
     | Compare(expr, cmpop, expr)
     | Call(expr, expr*)
     | Attribute(expr, identifier)
     -- No need for expr_context because no user made objects are allowed yet, thus
     -- modifying attributes is not necessary
     -- | Attribute(expr, identifier, expr_context)
     | Subscript(expr, expr, expr_context)  -- No arbitrary slice allowed yet
     | List(expr*)
     | Tuple(expr*) -- No expr_context for Tuple as `(a, b) = 1, 2` is not supported

stmt = Delete(expr+)
      | Assign(expr, expr)                -- a = 3
      | AugAssign(expr, operator, expr)   -- a += 3
      | AnnAssign(expr, expr, expr)       -- a: int = 3

      | While(expr, stmt+)
      | If(expr, stmt+, stmt*)

      | Import(alias+ names)
      | ImportFrom(identifier, alias+)

      | Expr(expr)

-- Indicates why are we looking up a variable, attribute or subscript
expr_context = Load | Store | Del

operator = Add | Sub | Mult | Div | Mod | Pow | LShift
             | RShift | FloorDiv

cmpop = Lt | LtE | Gt | GtE

-- import name with optional 'as' alias.
alias = (identifier, identifier?)
\end{verbatim}

This is same syntax that is used by the parser of CPython \autocite{van2007python}. The
developer is not supposed to write in this new syntax, but code written in this syntax is
the result of the parser. The parser takes code written in the first syntax and defines a
proper context (\verb|Load|, \verb|Store|, or \verb|Del|) for the expressions
\pycode+Name+ and \pycode+Subscript+. All other expressions are considered \verb|Load| by
default.

The contexts purpose is to indicate what the purpose of the returned value will be. The
following is the informal meaning of each context:

\begin{itemize}
\tightlist
\item[\textbf{Load}] indicates that the value will be either stored in heap or some further
  computation with it is required. For example, the result of evaluating the expression
  \pycode|b| in \pycode|b + 2| is a value, possibly a number, as it is going to be further
  used in the computation.
\item[\textbf{Store}] indicates that we want to save some value wherever the expression
  points to. For example, the result of evaluating the expression \pycode|b| in
  \pycode|b = 2| is the position in memory to which \pycode|b| is stored.
\item[\textbf{Del}] indicates that we want to delete the expression from where it is stored.
  For example, the result of evaluating the expression \pycode|b| in \pycode|del b| is the
  name that identifies the variable, \pycode|b|.
\end{itemize}

In CPython the expressions \pycode|Attribute|, \pycode|Subscript| and \pycode|Name| have a
context defined. In our formalisation only \pycode|Subscript| and \pycode|Name| have a
context defined because we are not interested in modifying or deleting the value of any
attribute. No attribute for builtin functions and objects can be modified or deleted, only
attributes from objects defined by on custom classes and functions can be deleted or
modified. For example, given the list \pycode|a = [2,3]|, the statements
\pycode|del a.insert| and \pycode|a.insert = 3| fail to execute.

The new state of the program is defined as a value from \verb+Global x Heap+, where:

\begin{verbatim}
Global = Iden -> Addr + Undefined -- Global scope
Heap = Addr -> Val + Undefined   -- Heap

Key = Iden + (string x (Iden + PrimVal))
Type = List | Tuple | Module

PrimVal = Int | Float | True | False | None | Undefined
Object = Type x Addr x (Key -> Addr + Undefined)
Val = PrimVal | Object | <prim-callable>

<prim-callable> = <prim-append> | <prim-+-int> | <prim-+-float> | <prim-*-int> | ...
\end{verbatim}

And the new semantics are defined as:

\begin{verbatim}
E[expr] :: Global x Heap
        -> Global
         x Heap
         x (Val + (Object x (string x Val)) + Iden)

E[Name(id, ctx)](G, H) :=
  match ctx in
    case Load  -> if G(id) = Undefined
                  then <Execution Halt>
                  else (G, H, H(G(id)))
    case Store -> (G, H, id)  -- ctx tells us that S[Assign(id, ...)]
    case Del   -> (G, H, id)  -- ctx tells us that S[Delete(id)]

E[Int(n)](G, H) := (G, H, n)

E[BinOp(op, a, b)](G, H) :=
  let (G1, H1, v1) := E[a](G, H)
      (G2, H2, v2) := E[b](G1, H1)
   in if kind(v1) /= Val  or  kind(v1) /= Val
      then <Execution Halt> -- error at parsing
      else let prim_op := get_prim_op(op, v1, v2)
            in prim_op(G2, H2)

S[Assign(var, val)](G, H) :=
  let (G1, H1, ass) := E[var](G, H)
      (G2, H2, rightval) := E[val](G1, H1)
      rval := if is_value(rightval) then val else <Execution Halt>
   in
      match ass in
        case Iden -> (G2[ass->rval], H2)

        case ((t, addr, o): Object, ('index', val: Val)) ->
          let setindex := get_prim_set_index(t)
          in setindex(G2, H2, o, val, addr, rval)

        otherwise -> <Execution Halt>
\end{verbatim}

% The increase in complexity of the semantics is required to handle all the
Notice that the number of \verb+<Execution Halt>+s in the semantics have increased. The
new \verb+<Execution Halt>+s are the result of an incorrect return value by an expression.
These new \verb+<Execution Halt>+s are considered the result of a failure by the parser.
The Abstract Interpreter will also fail if there is a failure in the parser, we suppose
that the parser works as intended.

Expressions return one of three different values
\verb|(Val + (Object x (string x Val)) + Iden)|. The value returned depends on the
context the expression is called and how is it accessed:

\begin{itemize}
\tightlist
\item[\textbf{Val}] is returned when the expressions \pycode|Subscript| and \pycode|Name|
  have context \verb|Load|. All other expressions return only \verb|Val|s.
\item[\textbf{Iden}] is returned when the expression \pycode|Name| has context \verb|Del|
  or \verb|Store|.
\item[\textbf{Object x (string x Val)}] is returned when the expression \pycode|Subscript|
  has context \verb|Del| or \verb|Store|.
\end{itemize}

% And a little more intricate example:
%
% \inlinetodo{add another example using a list that references itself and how that can be
% represented as a graph. Much easier to understand}

\section{Abstract Semantics}

In this section, we will define the abstract semantics of the language. To define them, we
need to define first an Abstract Domain for the state of the program. Concrete semantics
work on Python values (numbers, constants, functions, lists, etc) and abstract semantics
work on Abstract Python values.

First, we will define the Abstract Python values, the Abstract Domain propose. Finally, we
will show the new semantics, the abstract semantics.

\subsection{State Abstract Domain}

Before we define the Abstract Domain for a state of the program, \verb+Global x Heap+, we
will define the Abstract Domain for a primitive value in the language. Concrete
primitive values are defined as

\begin{verbatim}
PrimVal = Int | Float | True | False | None | Undefined
\end{verbatim}

The Abstract Domain for primitive values is constructed from individual Abstract Domains,
one Abstract Domain per each one of the types of values that \verb+PrimVal+ holds:

\input{figures/latice-primvals}

In this Abstract Domain, joining any two differing values gives us a $\top$. If both
values are of the same "type", e.g. both are \pycode+Int+s, then the $\top$ will "be" of
that type. For example, $5 \cup 6 = \top_{\text{Int}}$ and $5 \cup 6.2 = \top$.

The selected Abstract Domains for integers and floating point numbers are the simplest
Abstract Domains for numbers that work for Value Analysis. We do not use more complex
Abstract Domains, like intervals, because there is no need for them to analyse the shape
of tensors.

Recall that the semantics of a program work on states, thus we need to define an abstract
value for the abstract semantics to work with. Remember that the state of a program is a
value of type \verb+Global x Heap+. The abstract state of a program is defined as
\verb+Global# x Heap#+, where:

\begin{verbatim}
Global# = Iden -> Addr + Undefined  -- Abstract Global Scope
Heap# = Addr -> Val# + Undefined    -- Abstract Heap

PrimVal# = Int# | Float# | True# | False# | None | Undefined
Object# = Type x Addr x ((Key -> Addr + Undefined) + ImTop + ImBot)
Val# = PrimVal# | Object# | <prim-callable># | Top_Val | Bot_Val

<prim-callable> = <prim-append># | <prim-+-int># | <prim-+-float># | <prim-*-int># | ...
\end{verbatim}

Explaining in detail how is the Abstract Domain for the state defined is out of the scope
of chapter. A throughout explanation on the construction of the Abstract Domain can be
seen in the Appendix~\ref{appendix-ai-theory}. We will dedicate the rest of this section
to show the motivation to define an Abstract Domain for states.

Consider the following piece of code:

\begin{pythoncode}
if s:
  a = 2
  b = a + 3
  c = [0.0, a, b]
else:
  a = 3
  b = a + 2
  c = [1, a, b]
\end{pythoncode}

In the example, we do not know the value of \pycode+s+, and therefore, we have no idea
which of the two branches of the \pycode+if+ statement will be executed. The solution that
Abstract Interpretation presents us is to run both branches separately, each with a copy
of the state of the program. Then, all we need to do is to find an
\textbf{over}approximation of the two new states. Fortunately, finding an
overapproximation of the states is what we built an Abstract Domain for. The
\textit{join} ($\cup^{\text{State}}$) operation of an Abstract Domain tells us the
smallest common overapproximation between the two states.

We know that the state at the end of the \enquote{then} branch is \verb|(G1, H1)|, and the
state at the end of the \enquote{else} branch is \verb|(G2, H2)|, where:

\begin{verbatim}
G1 := {'s'-> 0, 'a'-> 1: 'b'-> 2: 'c'-> 3}  G2 := {'s'-> 0, 'a'-> 1: 'b'-> 2: 'c'-> 3}
H1 := {                                     H2 := {
  0 -> Top,                                   0 -> Top,
  1 -> 2,                                     1 -> 3,
  2 -> 5,                                     2 -> 5,
  3 -> (List, 3, {                            3 -> (List, 3, {
    'size' -> 4,                                'size' -> 4,
    ('index', 0) -> 5,                          ('index', 0) -> 5,
    ('index', 1) -> 6,                          ('index', 1) -> 6,
    ('index', 2) -> 7,                          ('index', 2) -> 7,
  }),                                         }),
  4 -> 3,                                     4 -> 3,
  5 -> 0.0,                                   5 -> 1,
  6 -> 2,                                     6 -> 3,
  7 -> 5,                                     7 -> 5,
}                                           }
\end{verbatim}

The result of joining the two states is \verb+(Gnew, Hnew)+, where:

\begin{verbatim}
Gnew := {'s'-> 0, 'a'-> 1: 'b'-> 2: 'c'-> 3}
Hnew := {
  0 -> Top,
  1 -> Top_Int,
  2 -> 5,
  3 -> (List, 3, {
    'size' -> 4,
    ('index', 0) -> 5,
    ('index', 1) -> 6,
    ('index', 2) -> 7,
  }),
  4 -> 3,
  5 -> Top,
  6 -> Top_Int,
  7 -> 5,
}
\end{verbatim}

Now that we have defined our abstract state, we can define the abstract semantics.

\subsection{Semantics for the Abstract State}

Defining the abstract semantics is quite straightforward. All we need to do is to modify
the concrete semantics to work with new values:

\begin{verbatim}
E#[expr] : Global# x Heap#
         -> Global#
          x Heap#
          x (Val# + (Object# x (string x Val#)) + Iden)

E#[Name(id, ctx)](G#, H#) :=
  match ctx in
    case Load  -> if G#(id) = Undefined
                  -- the variable `id` has not been defined then we "set" it in the global
                  -- scope and return `Top_Val`
                  then let ad := freeaddr(H#)
                        in (G#[id->ad], H#[ad->Top_Val], Top_Val)
                  else (G#, H#, G#(id))
    case Store -> (G, H, id)
    case Del   -> (G, H, id)

E#[Int(n)](G, H) := (G, H, n)

get_prim_op : Op x Val# x Val# -> Global x Heap -> Global x Heap x Val#

get_prim_op#(Add, v1, v2) :=
  match (type(v1), type(v2)) in
    case (Int, Int) -> \(G#, H#) -> <prim-+-int>#(v1, v2, G#, H#)
    case (Float, Float) -> \(G#, H#) -> <prim-+-float>#(v1, v2, G#, H#)
    case (Int, Bool) -> \(G#, H#)-> <prim-+-int>#(v1, Int(v2), G#, H#)
    case (Bool, Int) -> \(G#, H#)-> <prim-+-int>#(Int(v1), v2, G#, H#)
    case (Float, a) -> if a = Bool or a = Int
                       then \(G#, H#)-> <prim-+-float>#(v1, Float(v2), G#, H#)
                       else <prim-ret-top>#
    case (a, Float) -> if a = Bool or a = Int
                       then \(G#, H#)-> <prim-+-float>#(Float(v1), v2, G#, H#)
                       else <prim-ret-top>#
    case otherwise -> <prim-op-top>#

<prim-op-top># : Global# x Heap#
<prim-op-top>#(G#, H#) := (G#, H#, Top_Val)


S#[stmt] : Global# x Heap# -> Global# x Heap#

S#[Assign(var, val)](G#, H#) :=
  let (G1#, H1#, ass) := E[var](G#, H#)
      (G2#, H2#, rightval) := E[val](G1#, H1#)
      rval := if is_value#(rightval) then val else <Execution Halt>
   in
      match ass in
        case Iden -> (G2#[ass->rval], H2#)

        case ((t, addr, o): Object#, ('index', val: PrimVal#)) ->
          let setindex# := get_prim_set_index#(t)
          in setindex#(G2#, H2#, o, val, addr, rval)

        otherwise -> <Execution Halt>
\end{verbatim}

In the process of defining the new semantics, we can notice that the number of
\verb+<Execution Halt>+ expressions have reduced. Every \verb+<Execution Halt>+ that is
not the result of a parser error is caused by a type mismatch between values being
operated. An example of an execution halt caused by a type mismatch is \pycode|5 + None|
because no integer can be added to a \pycode|None|.

Executing a faulty piece of code now does not halt the interpreter:

\begin{pythoncode}
b = 2 + d
if b < 3:
  a = 2+3
else:
  a = 5-1+1
\end{pythoncode}

The state result of evaluating the function \verb|S#[b = 2 + d; a = b < 3]| is:

\begin{verbatim}
  G# := {
    d -> 0,
    b -> 1,
    a -> 2,
  }
  H# := {
    0 -> Top,
    1 -> Top,
    2 -> 5
  }
\end{verbatim}

\section{NdArrays}

The purpose of the formalisation is to be able to construct from it an Abstract
Interpreter. To test the Abstract Interpreter abilities to find bugs it should be able to
handle NumPy array (tensors). In this section, I extend the concrete semantics with NumPy
arrays.

The following are all the things to take into account when extending our formalisation to
handle a new type of \enquote{builtin} \pycode|Object| type:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Extend the types of \pycode|Object|s to handle NumPy arrays.

\begin{verbatim}
Type = List | Tuple | Module | NdArray
\end{verbatim}

  As an example, consider the numpy array \pycode|np.zeros((4, 3))|, it
  can be expressed as:

\begin{verbatim}
Object(NdArray,
 0xanumber,
 -- The shape of a NdArray is a tuple of integers
 { 'shape' -> Object(Tuple,
               0xothernum,
               { 'size' -> 2,
                 ('index', 0) -> 4,
                 ('index', 1) -> 3,
               }
              )
   ('index', 0) -> 0,
   ... -- all other indices, each one identified by an integer
 }
)
\end{verbatim}

  Note: Remember that an \pycode|Object| is a triple of the form
  \pycode|Type x Addr x (Key -> Addr + Undefined)|.
  Also remember that example above is faulty as the codomain of the
  function defined above is \pycode|Val| not \pycode|Addr| as it should
  be.
\item
  Extend primitive functions with NumPy's primitive functions. The
  NumPy's primitive functions implemented in the Abstract Interpreter
  are: \pycode|array|, \pycode|zeros|, \pycode|dot|, \pycode|ones|,
  \pycode|abs| (and all other functions that don't alter the shape of
  the tensor they take), \pycode|arange|, \pycode|size|, \pycode|ndim|,
  \pycode|astype|, and \pycode|T|.

\begin{verbatim}
<prim-callable> = ... (old operations) |
                  <prim-np-zeros> | <prim-np-dot> | <prim-np-abs> | ...
\end{verbatim}

  Note: The values stored inside a NumPy array are consider irrelevant
  in this work. The Value Analysis built in this work considers only the
  shape of tensors, as tensors can be huge and their contents do not
  often influence their shape. Therefore, it would be wasteful to give a
  detailed formalisation of the NumPy library primitives.

  Nonetheless, defining formaly each one of the NumPy functions above is
  fairly straightforward. Although, the hardest part of a formal
  defitinion of Numpy arrays is detailing how \pycode|array| works. To
  define the function \pycode|<np-array>| one
  must consider the many input cases it can handle, and it can handle
  almost any Python object\footnote{The NumPy function \pycode|array|
    takes almost anything as an input. \pycode|arrays| tries to
    interpret its input as an array in any way it can. There is no
    formal definition of how the values are interpreted althought its
    semantics can be extracted by looking at its C implementation:
    https://stackoverflow.com/a/40380014}.

  Once the \pycode|<np-array>| function is
  implemented all other functions are much simpler to define. As an
  example, the implementation of the function \pycode|size| is:

\begin{verbatim}
<prim-np-size>(val)(G, H) :=
   -- We know that `<prim-array>` always returns an NdArray
   let (G, H, (NdArray, addr, arr)) := <prim-array>(val)(G, H)
   -- We know that a NdArray has a special value called `shape`
       (Tuple, addrtup, tup) := arr('shape')
   in  tup('size')
\end{verbatim}
\item
  Extend the cases that \pycode|get_prim_op| handles to cover NumPy
  arrays. All operations defined in NumPy handle broadcasting.
  {\todo{Explain what broadcasting is}} For example:

\begin{verbatim}
get_prim_op(Add, v1, v2) :=
  match (type(v1), type(v2)) in
    ... -- old cases
    case (NdArray, t1) ->
      \(G, H)->
        let (G1, H1, ndarr) := <prim-array>(v2)(G, H)
        in  <prim-+-ndarray>(v1, ndarr, G1, H1)
    case (t1, NdArray) ->
      \(G, H)->
        let (G1, H1, ndarr) := <prim-array>(v1)(G, H)
        in  <prim-+-ndarray>(ndarr, v2, G1, H1)
    case otherwise -> <Execution Halt>
\end{verbatim}
\item
  The NumPy module holding all operations is defined:

\begin{verbatim}
<numpy-mod> := Object(Module,
 -1,  -- This value will be changed once it is imported
 { ('attr', 'array') -> <prim-array>,
   ('attr', 'dot')   -> <prim-dot>,
   ('attr', 'zeros') -> <prim-zeros>,
   ('attr', 'ones')  -> <prim-ones>,
   ...
 }
)
\end{verbatim}
\item
  And finally, \pycode|S[Import(name)]| is extended (now it handles
  a single library):

\begin{verbatim}
S[Import(name)](G, H) :=
  match name in
    ("numpy",) ->
      let (Module, arr, mod) := <numpy-mod>
          freeaddr := get_free_addr(H)
      in  (G['numpy'->freeaddr], H[freeaddr->(Module, freeaddr, mod)])
    ("numpy", alias) ->
      let (Module, arr, mod) := <numpy-mod>
          freeaddr := get_free_addr(H)
      in  (G[alias->freeaddr], H[freeaddr->(Module, freeaddr, mod)])

    otherwise -> <Execution Halt>
\end{verbatim}
\end{enumerate}


\section{Type Annotations}

Notice that we have not yet talked about the abstract semantics of \pycode|AnnAssign|.
The idea of type annotations is that they let us refine the value/type of a variable when
the Abstract Interpreter is unable to define a precise value.

An example of what annotations should be able to do is:

\begin{pythoncode}
from mypreciouslib import amatrix
from pytropos.hints.numpy import NdArray

mat: NdArray[1,12,6,7] = np.array(amatrix)
newmat = (mat + 12).reshape((12*6, -1))  # newmat has shape (12*6,7)
newmat = newmat.dot(np.ones((8, 21)))  # Error! Matrix multiplication, 7!=8
\end{pythoncode}

When one imports an arbitrary library like \pycode|mypreciouslib| it is
impossible to know what we may have imported so every variable imported
is a \verb|Top_Val|, i.e.~anything. By adding an annotation to
\pycode|mat|, we are telling the abstract interpreter that we know, and
are sure, of the shape of the NumPy array.

The semantics for \texttt{AnnAssign} are:

\begin{verbatim}
S[AnnAssign(var, hint, val)](G, H) :=
  let (G1, H1, evaluatedhint) := E[hint](G, H)
      (G2, H2, evaluatedhint) := E[hint](G1, H1)
      hintval := if isvalue#(evaluatedhint) then evaluatedhint else <Execution Halt>

   in S[Assign(var, val)](G1, H1)

  let (G1, H1, ass) := E[var](G, H)
      (G2, H2, evaledhint) := E[hint](G1, H1)
      (G3, H3, rightval) := E[val](G2, H2)
      compval := if is_value(rightval) then val else <Execution Halt>
      hintval := if isvalue#(evaledhint) then evaledhint else <Execution Halt>

      -- if `hintval` is more precise than `compval` we replace it
      rval := if hintval < compval then hintval else compval
   in
      ... -- Continue as in S[Assign(...)]
\end{verbatim}

Notice that we determine the \enquote{precision} of a hint with respect to the variable
with the comparision between values, the order \verb|Val#|!
