\chapter{Abstract Interpretation for Python}\label{ai-for-python}

In this chapter, an Abstract Interpreter for Python is proposed. The chapter is divided
into five parts: definition of semantics, concrete semantics for Value Analysis of Python
code, abstract semantics from the concrete semantics, an extension to abstract semantics
to work with NumPy arrays, and the abstract semantics of type annotations. This chapter is
intended as a guide on how was the Abstract Interpreter built. A deeper look at the gory
details of the concrete and abstract semantics are given in
Appendix~\ref{appendix-ai-theory}.

\section{Semantics}

In Mathematics, the word \enquote{semantics} refers to the meaning of sentences in formal
languages \autocite{gunter_semantics_1992}. The semantics of programming languages
consist of what a piece of code means, how to interpret it, and how to analyse it.

% \todo{find a better reference for the classification categories}

\textcite{mitchell1996foundations} classifies programming languages semantics into three
categories: axiomatic, denotational, and operational. Axiomatic semantics describe the
behaviour of code with mathematical logic. Denotational semantics goal is to find a
mathematical \enquote{object} that represents what a program does. The program meaning is
given by the object properties or lack of thereof. Operational semantics are concerned
with rules that tell how to interpret or execute a piece of code. No meaning is given to
the parts of the program, but a meaning is given as the program is run.

\begin{figure}
\begin{center}
\begin{forest}
for tree={
  draw,
  minimum height=1cm,
  anchor=north,
  align=center,
  child anchor=north
},
[{Semantics of\\Programming Languages}, align=center
  [{Axiomatic\\Semantics}
    [Hoare Logic]
  ]
  [{Denotational\\Semantics}]
  [{Operational\\Semantics}
    [{Small-step Semantics}]
    [{Big-step Semantics}]
  ]
]
\end{forest}
\end{center}
\caption{Classification of programming languages semantics by \textcite{mitchell1996foundations}}
\end{figure}

On the one hand, denotational semantics must not provide a way to determine an implementation.
On the other hand, an implementation can be easily built from operational semantics.
Small-step semantics, one kind of operational semantics, define what the program does by
describing a set of rules over the syntax of the language. The meaning of the program is
given by the application of the rules. The set of rules is often a specification of what a
compiler does. Thus, it is not surprising that all efforts to define a formal semantics for
Python have been small-step semantics as it is easy to define rules from the translation
process from code to \enquote{binary}
\autocites{ranson_semantics_2008}{guth_formal_2013}{politz_python_2013}{fromherz_static_2018}.

We also define some small-steps semantics for Python. We define them from the execution
model of CPython, that is, the official implementation of the Python language. In the
following two sections, we define the small-step semantics of a portion of Python, our
concrete semantics for the problem; and, based on them we will define some abstract
semantics for Python.

\section{Concrete Semantics of Python}

Before we define the concrete semantics of Python, we need to define how to write a piece
of code in Python. Python is a mature and large language, thus we will take just a portion
of it into account. In Figure~\ref{syntaxPython}, we present the subset of Python that we intend to
study in this work.

\begin{figure}
\[\begin{array}{rclr}
    expr  &:=& i \in \mathbb{Z} \alt j \in \texttt{float} \alt \texttt{True} \alt
    \texttt{False} \alt \texttt{None} & \textit{primitive values} \\
     &\alt& identifier & \textit{variable name} \\
     %&\alt& \texttt{Undefined} & \textit{wildcard value} \\
     &\alt& expr~op~expr \alt expr~cmpop~expr & \textit{binary operations} \\
     &\alt& expr\texttt{(}expr*\texttt{)}     & \textit{function call} \\
     &\alt& expr\texttt{.}identifier & \textit{attribute access} \\
     &\alt& expr\texttt{[}expr\texttt{]}      & \textit{subscript access} \\
     &\alt& \texttt{[}expr*\texttt{]}         & \textit{lists} \\
     &\alt& \texttt{(}expr*\texttt{)}         & \textit{tuples} \\

  stmt &:=& \texttt{del } expr  & \textit{delete} \\
     &\alt& expr = expr         & \textit{assignment} \\
     &\alt& expr~op\hspace{-0.35em}\texttt{ = } expr       & \textit{augmented assignment} \\
     &\alt& expr\texttt{: } expr \texttt{ = } expr   & \textit{type annotation} \\
     &\alt& \texttt{while } expr\texttt{: } stmt^+   & \textit{loop} \\
     &\alt& \texttt{if } expr\texttt{: } stmt^+   & \textit{if} \\
     &\alt& \texttt{import } alias^+
     \alt \texttt{from } identifier \texttt{ import } alias^+   & \textit{import library} \\
     &\alt& expr & \\

  op &:=& \texttt{+} \alt \texttt{-} \alt \texttt{*} \alt \texttt{/} \alt \texttt{\%} \alt \texttt{**} \alt
      \texttt{<<} \alt \texttt{>>} \alt \texttt{//}  & \\
  cmpop &:=& \texttt{<} \alt \texttt{<=} \alt \texttt{>} \alt \texttt{>=}  & \\

  alias &:=& identifier \alt identifier \texttt{ as } identifier  & \\

  %identifier &:=& str  & \\
\end{array}\]
\caption{Reduced python syntax used throughout this work.\label{syntaxPython}}
\end{figure}

We intentionally omit any details related to the spacing of blocks in Python, as our main
focus is the meaning of Python values and not how blocks of statements are defined in the
language.

We follow the same approach taken by \autocite{fromherz_static_2018} and define the state
of the program with a global scope and a heap.
Python memory is represented as a function from memory positions ($\mathbf{Addr}$) to
python values ($\mathbf{Val}$). The global scope is defined as a function from identifiers
($\mathbf{Iden}$) to memory positions ($\mathbf{Addr}$).

$$\begin{array}{rcl}
  \mathbf{Global}  &:=& \mathbf{Iden} \to \mathbf{Addr} \cup \{\undefm\} \\
  \mathbf{Heap}  &:=& \mathbf{Addr} \to \mathbf{Val} \cup \{\undefm\} \\
\end{array}$$

In Python, everything is an object: numbers, lists, classes and even functions. We separate
python values into three categories: primitive values, like numbers, booleans and
\pycode+None+; \verb+Object+s, like lists and tuples; and, primitive functions, like
\pycode+int.__add__+.

$$\begin{array}{rcl}
  \mathbf{Val} &:=& \mathbf{PrimVal} \alt \mathbf{Object} \alt \textbf{\texttt{<prim-callable>}} \\
  \mathbf{PrimVal} &:=& i \in \mathbb{Z} \alt j \in \texttt{float} \alt \texttt{True} \alt \texttt{False} \alt \texttt{None} \\
  \mathbf{Object} &:=& \mathbf{Type} \times \mathbf{Addr} \left(\mathbf{Key} \to \mathbf{Addr} \cup \{\undefm\}\right) \\
  \mathbf{Type} &:=& \texttt{List} \alt \texttt{Tuple} \\
  \mathbf{Key} &:=& \mathbf{Iden} + \left(\textsf{string} \times \mathbf{Val}\right) \\
\end{array}$$

We can now define the rules that describe the behaviour of a program, that is, the
small-step semantics of the language. The equations $\Ctx{E}{expr}$ and $\Ctx{S}{stmt}$
from Figure~\ref{smallstep1} define the small-step semantics.

\begin{figure}

\begin{minipage}{.46\textwidth}
\[\begin{array}{rl}
  \Ctx{E}{expr} :& \mathbf{Global} \times \mathbf{Heap} \\
  &\to \mathbf{Global} \times \mathbf{Heap} \times \mathbf{Val} \\
\end{array}\]
\[
  \begin{array}{l}
    \Ctx{E}{identifier}\left(\Glo, \Hea\right) := \\
    \quad \ifm \Glo(identifier) = \undefm \\
    \quad \thenm \Halt \\
    \quad \elsem \left(\Glo, \Hea, \Hea\left(\Glo\left(identifier\right)\right)\right) \\
    \\
    \Ctx{E}{n}\left(\Glo, \Hea\right) := \left(\Glo, \Hea, n\right) \quad \text{for all } n \in \mathbb{Z}\\
    \\
    \Ctx{E}{expr_1~op~expr_2}\left(\Glo, \Hea\right) := \\
    \quad \letm
    \begin{aligned}[t]
       \left(\Glo_1, \Hea_1, v_1\right) &:= \Ctx{E}{expr_1}\left(\Glo, \Hea\right) \\
       \left(\Glo_2, \Hea_2, v_2\right) &:= \Ctx{E}{expr_2}\left(\Glo_1, \Hea_1\right) \\
       prim\_op &:= get\_prim\_op\left(op, v_1, v_2\right) \\
    \end{aligned} \\
    \quad \inm prim\_op\left(\Glo_2, \Hea_2\right)
  \end{array}
\]
\end{minipage}%
\hfill%
\begin{minipage}{.46\textwidth}
\[\Ctx{S}{stmt} : \mathbf{Global} \times \mathbf{Heap} \to \mathbf{Global} \times \mathbf{Heap}\]
\[
  \begin{array}{l}
    \Ctx{S}{stmt_1\texttt{; } stmt_2}\left(\Glo, \Hea\right) := \\
    \quad \letm \left(\Glo_1, \Hea_1\right) := \Ctx{S}{stmt_1}\left(\Glo, \Hea\right) \\
    \quad \inm \Ctx{S}{stmt_2}\left(\Glo_1, \Hea_1\right) \\
    \\
    \Ctx{S}{identifier = expr}\left(\Glo, \Hea\right) := \\
    \quad \letm
    \begin{aligned}[t]
      \left(\Glo_1, \Hea_1, val\right) &:= \Ctx{E}{expr}\left(\Glo, \Hea\right) \\
      adnew &:= get\_free\_addr(\Hea_1) \\
    \end{aligned}\\
    \quad \inm \left(\Glo_1[identifier \to adnew], \Hea_1[adnew \to val]\right) \\
  \end{array}
\]
\[
  \begin{array}{l}
    \Glo_{empty} : \mathbf{Global} \\
    \Glo_{empty} := \undefm \\
    \\
    \Hea_{empty} : \mathbf{Heap} \\
    \Hea_{empty} := \undefm \\
  \end{array}
\]
\end{minipage}
\caption{A portion of the Small-steps semantics for Python. The functions $get\_prim\_op$
  and $get\_free\_addr$ are defined in Appendix~\ref{appendix-ai-theory}\label{smallstep1}}
\end{figure}

% \begin{verbatim}
% get_prim_op : string x Val x Val -> Global x Heap -> Global x Heap x Addr
% get_prim_op(op, v1, v2) :=
%   match (type(v1), type(v2)) in
%     case (int, int) -> \(G, H) -> <prim-+-int>(v1, v2, G, H)
%     case (float, float) -> \(G, H) -> <prim-+-float>(v1, v2, G, H)
%     case (int, bool) -> \(G, H)-> <prim-+-int>(v1, to_int(v2), G, H)
%     case (bool, int) -> \(G, H)-> <prim-+-int>(to_int(v1), v2, G, H)
%     case (float, a) -> if a = Bool or a = Int
%                        then \(G, H)-> <prim-+-float>(v1, to_float(v2), G, H)
%                        else <Execution Halt>
%     case (a, float) -> if a = Bool or a = Int
%                        then \(G, H)-> <prim-+-float>(to_float(v1), v2, G, H)
%                        else <Execution Halt>
%     -- This function is to be extended once we add NdArrays to the mix
%     case otherwise -> <Execution Halt>
%
% <prim-+-int> : Val x Val x Global x Heap -> Global x Heap x Val
% <prim-+-int>(i, j, G, H) := (G, H, i+j)
%
% get_free_addr : Heap -> Addr
% get_free_addr(H) := max({ad in H | H(ad) != Undefined}, -1) + 1
% \end{verbatim}

The construction $\Halt$ indicates that the evaluation cannot go any further, i.e. the
interpreter will stop and throw an exception. For example, accessing a variable that
has not yet been defined is considered an error (Python will throw an exception if this
happens).

The meaning of our program is given by the function $\Ctx{S}{stmt}$ with type
$\mathbf{State} \to \mathbf{State}$ (where $\mathbf{State} := \mathbf{Global} \times \mathbf{Heap}$).
In this work, we are interested on the values that result from the application of the
fuction $\Ctx{S}{stmt}$ on a clean state, which is a state that has only built-in variables
defined.  Statements modify the state of the program while expressions modify the state of
the program and return a python value as result, e.g. the expression \pycode+ls.pop()+
removes the last element in the list \pycode+ls+ and returns the value contained. This is
the reason why the type of the function $\Ctx{E}{expr}$ is
$\mathbf{State} \to \mathbf{State} \times \mathbf{Val}$.

Let us consider the simple program:

\begin{pythoncode}
b = 2
a = b + 3
\end{pythoncode}

We can apply the semantics rules on the example by evaluating
$\Ctx{S}{b \texttt{ = } 2\texttt{; } a \texttt{ = } b \texttt{ + } 3}\left(\Glo_{empty}, \Hea_{empty}\right)$.
Figure~\ref{evaluatingprog} presents the step by step of the evaluation.

\begin{figure}
\[
  \begin{array}{l}
    \Ctx{S}{b \texttt{ = } 2\texttt{; } a \texttt{ = } b \texttt{ + } 3}\left(\Glo_{empty}, \Hea_{empty}\right) \\
    \quad \eqdef
      \begin{aligned}[t]
        &\letm \left(\Glo_1, \Hea_1\right) := \Ctx{S}{b \texttt{ = } 2}\left(\Glo_{empty}, \Hea_{empty}\right) \\
        &\inm \Ctx{S}{a \texttt{ = } b \texttt{ + } 3}\left(\Glo_1, \Hea_1\right) \\
      \end{aligned}\\
    \\
    \quad\vrule\quad
      \begin{aligned}[t]
        &\Ctx{S}{b \texttt{ = } 2}\left(\Glo_{empty}, \Hea_{empty}\right) \\
        &\quad\eqdef
        \begin{aligned}[t]
          &\letm
          \begin{aligned}[t]
            \left(\Glo_1, \Hea_1, val\right) &:= \Ctx{E}{2}\left(\Glo_{empty}, \Hea_{empty}\right) \\
            adnew &:= get\_free\_addr(\Hea_1) \\
          \end{aligned}\\
          &\inm \left(\Glo_1[b \mapsto adnew], \Hea_1[adnew \mapsto val]\right) \\
        \end{aligned}\\
        &\quad\eqdef
        \begin{aligned}[t]
          &\letm
          \begin{aligned}[t]
            \left(\Glo_1, \Hea_1, val\right) &:= \left(\Glo_{empty}, \Hea_{empty}, 2\right) \\
            adnew &:= get\_free\_addr(\Hea_1) \\
          \end{aligned}\\
          &\inm \left(\Glo_1[b \mapsto adnew], \Hea_1[adnew \mapsto val]\right) \\
        \end{aligned}\\
        &\quad=
        \begin{aligned}[t]
          &\letm adnew := get\_free\_addr(\Hea_{empty}) \\
          &\inm \left(\Glo_{empty}[b \mapsto adnew], \Hea_{empty}[adnew \mapsto 2]\right) \\
        \end{aligned}\\
        &\quad=
        \begin{aligned}[t]
          &\letm adnew := 0 \\
          &\inm \left(\Glo_{empty}[b \mapsto adnew], \Hea_{empty}[adnew \mapsto 2]\right) \\
        \end{aligned}\\
        &\quad= \left(\Glo_{empty}[b \mapsto 0], \Hea_{empty}[0 \mapsto 2]\right) \\
        &\quad= \left([b \mapsto 0], [0 \mapsto 2]\right) \quad \textit{simplifying notation} \\
      \end{aligned}\\
    \\
    \quad=
      \begin{aligned}[t]
        &\letm \left(\Glo_1, \Hea_1\right) := \left([b \mapsto 0], [0 \mapsto 2]\right) \\
        &\inm \Ctx{S}{a \texttt{ = } b \texttt{ + } 3}\left(\Glo_1, \Hea_1\right) \\
      \end{aligned}\\
    \quad=\Ctx{S}{a \texttt{ = } b \texttt{ + } 3}\left([b \mapsto 0], [0 \mapsto 2]\right) \\
    \\
    \quad\eqdef
    \begin{aligned}[t]
      \letm
        \begin{aligned}[t]
          \left(\Glo_1, \Hea_1, val\right) &:= \Ctx{E}{b \texttt{ + } 3}\left([b \to 0], [0 \to 2]\right) \\
          adnew &:= get\_free\_addr(\Hea_1) \\
        \end{aligned}\\
      \quad \inm \left(\Glo_1[a \mapsto adnew], \Hea_1[adnew \mapsto val]\right) \\
    \end{aligned}\\
    \\
    \quad= \cdots = \\
    \\
    \quad=
    \begin{aligned}[t]
      \letm
        \begin{aligned}[t]
          \left(\Glo_1, \Hea_1, val\right) &:= \left([b \mapsto 0], [0 \mapsto 2], 5\right) \\
          adnew &:= get\_free\_addr(\Hea_1) \\
        \end{aligned}\\
      \quad \inm \left(\Glo_1[a \mapsto adnew], \Hea_1[adnew \mapsto val]\right) \\
    \end{aligned}\\
    \quad=
    \begin{aligned}[t]
      &\letm adnew := get\_free\_addr([0 \mapsto 2]) \\
      &\inm \left([b \mapsto 0][a \mapsto adnew], [0 \mapsto 2][adnew \mapsto 5]\right) \\
    \end{aligned}\\
    \quad= \left([b \mapsto 0][a \mapsto 1], [0 \mapsto 2][1 \mapsto 5]\right) \\
    \quad= \left([b \mapsto 0, a \mapsto 1], [0 \mapsto 2, 1 \mapsto 5]\right) \\
  \end{array}
\]
  \caption{Evaluation of the program \pycode|b = 2; a = b +3| with the small-step
    semantics from Figure~\ref{smallstep1}\label{evaluatingprog}}
\end{figure}

% \begin{verbatim}
%    (def)= let (G1, H1, val) := E[b + 3]({b->0}, {0->2})
%               adnew := get_free_addr(H)
%            in (G1[a->adnew], H1[adnew->val])
%
% >  E[b + 3]({b->0}, {0->2})
% >    (def)= let (G1, H1, v1) := E[b]({b->0}, {0->2})
% >               (G2, H2, v2) := E[3](G1, H1)
% >               prim_op := get_prim_op(+, v1, v2)
% >            in prim_op(G2, H2)
%
% >>  E[b]({b->0}, {0->2})
% >>     (def)= if {b->0}(b) = Undefined
% >>            then <Execution Halt>
% >>            else (G, H, H(G(b)))
% >>          = ({b->0}, {0->2}, {0->2}({b->0}(b)))
% >>          = ({b->0}, {0->2}, {0->2}(0))
% >>          = ({b->0}, {0->2}, 2)
%
% >         = let (G1, H1, v1) := ({b->0}, {0->2}, 2)
% >               (G2, H2, v2) := E[3](G1, H1)
% >               prim_op := get_prim_op(+, v1, v2)
% >            in prim_op(G2, H2)
% >         = let (G2, H2, v2) := E[3]({b->0}, {0->2})
% >               prim_op := get_prim_op(+, 2, v2)
% >            in prim_op(G2, H2)
% >         = let (G2, H2, v2) := ({b->0}, {0->2}, 3)
% >               prim_op := get_prim_op(+, 2, v2)
% >            in prim_op(G2, H2)
% >         = let prim_op := get_prim_op(+, 2, 3)
% >            in prim_op({b->0}, {0->2})
% >         = ... jumping a couple of transitions
% >         = <prim-+-int>(2, 3, {b->0}, {0->2})
% >         = ({b->0}, {0->2}, 5)
%
%         = let (G1, H1, val) := ({b->0}, {0->2}, 5)
%               adnew := get_free_addr(H)
%            in (G1[a->adnew], H1[adnew->5])
%         = let adnew := get_free_addr({0->2})
%            in ({b->0}[a->adnew], {0->2}[adnew->5])
%         = let adnew := 1
%            in ({b->0}[a->adnew], {0->2}[adnew->5])
%         = ({b->0}[a->1], {0->2}[1->5])
%         = ({b->0, a->1}, {0->2, 1->5}) -- end of execution
% \end{verbatim}

At the end of the execution, the state of the program is:

\noindent
\begin{minipage}{.46\textwidth}
\[\begin{array}{rcl}
  \Glo_{output} : \mathbf{Iden} &\to& \mathbf{Addr} \cup \{\undefm\} \\
  \texttt{'a'} &\mapsto& 1 \\
  \texttt{'b'} &\mapsto& 0 \\
  id &\mapsto& \undefm \\
\end{array}\]
\end{minipage}%
\hfill%
\begin{minipage}{.46\textwidth}
\[\begin{array}{rcl}
  \Hea_{output} : \mathbf{Addr} &\to& \mathbf{Val} \cup \{\undefm\} \\
  0 &\mapsto& 2 \\
  1 &\mapsto& 5 \\
  n &\mapsto& \undefm \\
\end{array}\]
\end{minipage}%

This is telling us that the variables \pycode+a+ and \pycode+b+ hold the values
\pycode+2+ and \pycode+5+, respectively.

Notice that we have not yet defined the semantics for the general case
$\Ctx{S}{expr_1 = expr_2}$ but only for the case $\Ctx{S}{identifier = expr}$.
Defining the small-step semantics on the syntax presented before is inconvenient. To see
why working with this syntax is inconvenient, observe that the delete statement,
$\texttt{del } expr$, does not expect a value from the evaluation of the expression
$expr$ but a name or position in memory.  Both \pycode|del a| and \pycode|ls = [1,9,4,5];
del ls[2]| are valid python statements, but their semantics vary depending on the
expression being evaluated. Inversely, the return value of evaluating expressions depends
on the context they are being called, the expression \pycode|ls[2]| returns a value or a
position in memory depending on the context is being used. \pycode|4 + ls[2]|,
\pycode|ls[2] = 4| and \pycode|del ls[2]| are examples of the three different contexts
where \pycode|ls[2]| can be called.
% The delete statement is not only able to remove values from the global scope, e.g
% \pycode+del a+, but it can also delete elements from a list, e.g. \pycode+del ls[2]+.

How could an expression like \pycode|ls[2]| know the context where it is going to be used?
We opted to follow what CPython does. CPython extends the syntax of expressions to allow
them to know the context from where they are being called. The new (extended) syntax can be
seen in Figure~\ref{syntaxPython2}.

\begin{figure}
\[\begin{array}{rclr}
    expr  &:=& \texttt{Int(}i\texttt{)} \textit{ for } i \in \mathbb{Z}
          \alt \texttt{Float(}j\texttt{)} \textit{ for } j \in \texttt{float} \\
          &\alt& \texttt{True}
          \alt \texttt{False} \alt \texttt{None}   & \textit{primitive values} \\
     &\alt& \SLit{Name}{identifier, expr\_context} & \textit{variable name} \\
     %&\alt& \texttt{Undefined} & \textit{wildcard value} \\
     &\alt& \SLit{BinOp}{op, expr, expr} \\
     &\alt&   \SLit{Compare}{expr, cmpop, expr}             & \textit{binary operations} \\
     &\alt& \SLit{Call}{expr, expr*}                    & \textit{function call} \\
     &\alt& \SLit{Attribute}{expr, identifier}          & \textit{attribute access} \\
     &\alt& \SLit{Subscript}{expr, expr, expr\_context} & \textit{subscript access} \\
     &\alt& \SLit{List}{expr*}                          & \textit{lists} \\
     &\alt& \SLit{Tuple}{expr*}                         & \textit{tuples} \\

  stmt &:=& \SLit{Delete}{expr}                      & \textit{delete} \\
     &\alt& \SLit{Assign}{expr, expr}              & \textit{assignment} \\
     &\alt& \SLit{AugAssign}{expr, op, expr}       & \textit{augmented assignment} \\
     &\alt& \SLit{AnnAssign}{expr, expr, expr}     & \textit{type annotation} \\
     &\alt& \SLit{While}{expr, stmt^+}             & \textit{loop} \\
     &\alt& \SLit{If}{expr, stmt^+}                & \textit{if} \\
     &\alt& \SLit{Import}{alias^+}                 & \textit{if} \\
     &\alt& \SLit{ImportFrom}{identifier, alias^+} & \textit{import library} \\
     &\alt& \SLit{Expr}{expr}                      & \\

  expr\_context &:=& \SLoad \alt \SStore \alt \SDel  & \\

  op &:=& \texttt{Add} \alt \texttt{Sub} \alt \texttt{Mult} \alt \texttt{Div} \alt
         \texttt{Mod} \alt \texttt{Pow} \\
     &\alt& \texttt{LShift} \alt \texttt{RShift} \alt \texttt{FloorDiv}  & \\
  cmpop &:=& \texttt{Lt} \alt \texttt{LtE} \alt \texttt{Gt} \alt \texttt{GtE}  & \\

  alias &:=& identifier \alt (identifier, identifier) & \\

  %identifier &:=& str  & \\
\end{array}\]
\caption{Python syntax used to define the semantics of the Abstract Interpreter.\label{syntaxPython2}}
\end{figure}

This is the same syntax that is used by the parser implemented by CPython
\autocite{van2007python}. The developer is not supposed to write in this new syntax. The
parser takes code written in the first syntax and defines a proper context (\verb|Load|,
\verb|Store|, or \verb|Del|) for the expressions \pycode+Name+ and \pycode+Subscript+. All
other expressions are considered \verb|Load| by default.

The following is the informal meaning of each context:

\begin{itemize}
\tightlist
\item[\textbf{Load}] indicates that the result of evaluating the expression will be used
  in further computations. For example, the result of evaluating the expression \pycode|b|
  in \pycode|b + 2| is a value.
\item[\textbf{Store}] indicates that we want to save to the expression a value. For
  example, the result of evaluating the expression \pycode|b| in \pycode|b = 2| is the
  location of \pycode|b| in the global scope.
\item[\textbf{Del}] indicates that we want to delete the expression from where it is stored.
  For example, the result of evaluating the expression \pycode|b| in \pycode|del b| is the
  name that identifies the variable, \pycode|b|.
\end{itemize}

In CPython, the expressions \pycode|Attribute|, \pycode|Subscript| and \pycode|Name| have a
context as part of their definition. In our specification, only \pycode|Subscript| and
\pycode|Name| have a context as we are not interested in modifying or deleting the value
of any attribute. No attribute for built-in functions and objects can be modified or
deleted. For example, given the list \pycode|a = [2,3]|, the statements
\pycode|del a.insert| and \pycode|a.insert = 3| are erroneous in Python, thus we have no
need to allow \pycode|Attribute|s to be deleted or modified.

% The new state of the program is defined as a value from \verb+Global x Heap+, where:
%
% \begin{verbatim}
% Global = Iden -> Addr + Undefined -- Global scope
% Heap = Addr -> Val + Undefined   -- Heap
%
% Key = Iden + (string x (Iden + PrimVal))
% Type = List | Tuple | Module
%
% PrimVal = Int | Float | True | False | None | Undefined
% Object = Type x Addr x (Key -> Addr + Undefined)
% Val = PrimVal | Object | <prim-callable>
%
% <prim-callable> = <prim-append> | <prim-+-int> | <prim-+-float> | <prim-*-int> | ...
% \end{verbatim}

In Figure~\ref{smallstep2}, the small-step semantics for the new syntax are presented.

\begin{figure}
\[\begin{array}{rl}
  \Ctx{E}{expr} :& \mathbf{Global} \times \mathbf{Heap} \\
  &\to \mathbf{Global} \\
  &\times \mathbf{Heap} \\\
  &\times \mathbf{Val} \cup (\mathbf{Object} \times (\textsf{string} \times \mathbf{Val})) \cup \mathbf{Iden} \\
\end{array}\]
\[\arraycolsep=1.4pt
  \begin{array}[t]{l}
    \Ctx{E}{\SLit{Name}{id}}\left(\Glo, \Hea\right) := \\
    \quad \matchm{ctx} \\
    \qquad \begin{array}[t]{lclr}
      \casem{\SLoad} &\to&
         \begin{array}[t]{l}
            \ifm \Glo(id) = \undefm \\
            \thenm
               \begin{array}[t]{l}
                  \ifm isbuiltin(id) \\
                  \thenm \left(\Glo, \Hea, \texttt{<builtin-val>}(id)\right) \\
                  \elsem \Halt \\
               \end{array} \\
            \elsem \left(\Glo, \Hea, \Hea\left(\Glo\left(id\right)\right)\right) \\
         \end{array} \\
      \casem{\SStore} &\to& \left(\Glo, \Hea, id\right) \quad \textit{to be assigned} \\
      \casem{\SDel} &\to& \left(\Glo, \Hea, id\right) \quad \textit{to be deleted} \\
    \end{array}\\
    \\
    \Ctx{E}{\SLit{Int}{n}}\left(\Glo, \Hea\right) := \left(\Glo, \Hea, n\right) \\
    \\
    \Ctx{E}{\SLit{BinOp}{op, a, b}}\left(\Glo, \Hea\right) := \\
    \quad \letm
       \begin{array}[t]{cl}
          \left(\Glo_1, \Hea_1, v_1\right) &:= \Ctx{E}{a}\left(\Glo, \Hea\right) \\
          \left(\Glo_2, \Hea_2, v_2\right) &:= \Ctx{E}{b}\left(\Glo_1, \Hea_1\right) \\
          prim\_op &:= get\_prim\_op\left(op, v_1, v_2\right) \\
       \end{array} \\
    \quad \inm
       \begin{array}[t]{l}
         \ifm kind(v_1) \neq \mathbf{Val} \vee kind(v_2) \neq \mathbf{Val} \\
         \thenm \Halt \\
         \elsem
            \begin{array}[t]{rl}
              \letm& prim\_op := get\_prim\_op\left(op, v_1, v_2\right) \\
              \inm& prim\_op\left(\Glo_2, \Hea_2\right)
            \end{array} \\
       \end{array} \\
    \\
    \Ctx{S}{\SLit{Assign}{var, val}}\left(\Glo, \Hea\right) := \\
    \quad \letm
       \begin{array}[t]{cl}
          \left(\Glo_1, \Hea_1, ass\right) &:= \Ctx{E}{var}\left(\Glo, \Hea\right) \\
          \left(\Glo_2, \Hea_2, rightval\right) &:= \Ctx{E}{val}\left(\Glo_1, \Hea_1\right) \\
          rval &:= \ifm is\_value(rightval) \;\thenm val \;\elsem \Halt \\
       \end{array} \\
    \quad \inm \matchm{ass} \\
    \qquad \casem{id: \mathbf{Val}} \to \left(\Glo_2[ass \mapsto rval], \Hea_2\right) \\
    \qquad \casem{((t, addr, o): \mathbf{Object}, (\texttt{'index'}, val: \mathbf{Val}))} \to \\
    \qquad\quad\begin{array}[t]{rl}
            \letm& setindex := get\_prim\_set\_index(t) \\
             \inm& setindex\left(\Glo_2, \Hea_2, o, val, addr, rval\right) \\
    \end{array} \\
    \qquad \casem{\textsf{otherwise}} \to \Halt \\
  \end{array}\]
\caption{Small-step (concrete) semantics for Python using syntax from
  Figure~\ref{syntaxPython2}.\label{smallstep2}}
\end{figure}

% The increase in complexity of the semantics is required to handle all the
Notice that the number of \verb+<Execution Halt>+s in the semantics have increased. The
new \verb+<Execution Halt>+s are the result of an incorrect return value by an expression.
These new \verb+<Execution Halt>+s are considered the result of a failure by the parser.
The Abstract Interpreter will also fail if there is a failure in the parser, we suppose
that the parser works as intended.

Expressions return one of three different values
\verb|(Val + (Object x (string x Val)) + Iden)|. The value returned depends on the
context the expression is called and how is it accessed:

\begin{itemize}
\tightlist
\item \textbf{Val}: is returned when the expressions \pycode|Subscript| and \pycode|Name|
  have context \verb|Load|. All other expressions return only \verb|Val|s.
\item \textbf{Iden}: is returned when the expression \pycode|Name| has context \verb|Del|
  or \verb|Store|.
\item \textbf{Object $\times$ (string $\times$ Val)}: is returned when the expression \pycode|Subscript|
  has context \verb|Del| or \verb|Store|.
\end{itemize}

% And a little more intricate example:
%
% \inlinetodo{add another example using a list that references itself and how that can be
% represented as a graph. Much easier to understand}

\section{Abstract Semantics}

In this section, we will define the abstract semantics of the language. To define them, we
need to define first an Abstract Domain for the state of the program. Concrete semantics
work on Python values (numbers, constants, functions, lists, etc) and abstract semantics
work on Abstract Python values.

First, we will define the Abstract Python values, the Abstract Domain propose. Finally, we
will show the new semantics, the abstract semantics.

\subsection{State Abstract Domain}

Before we define the Abstract Domain for a state of the program, \verb+Global x Heap+, we
will define the Abstract Domain for a primitive value in the language. Concrete
primitive values are defined as

\begin{verbatim}
PrimVal = Int | Float | True | False | None | Undefined
\end{verbatim}

The Abstract Domain for primitive values is constructed from individual Abstract Domains,
one Abstract Domain per each one of the types of values that \verb+PrimVal+ holds as it
can be seen in Figure~\ref{latticevals}.

\begin{figure}
  \begin{center}
  \input{figures/latice-primvals}
  \end{center}
  \caption{Lattice/Abstract Domain for primitive values.\label{latticevals}}
\end{figure}

In this Abstract Domain, joining any two differing values gives us a $\top$. If both
values are of the same "type", e.g. both are \pycode+Int+s, then the $\top$ will "be" of
that type. For example, $5 \cup 6 = \top_{\text{Int}}$ and $5 \cup 6.2 = \top$.

The selected Abstract Domains for integers and floating point numbers are the simplest
Abstract Domains for numbers that work for Value Analysis. We do not use more complex
Abstract Domains, like intervals, because there is no need for them to analyse the shape
of tensors.

Recall that the semantics of a program work on states, thus we need to define an abstract
value for the abstract semantics to work with. Remember that the state of a program is a
value of type \verb+Global x Heap+. The abstract state of a program is defined as
\verb+Global# x Heap#+, where:

\begin{verbatim}
Global# = Iden -> Addr + Undefined  -- Abstract Global Scope
Heap# = Addr -> Val# + Undefined    -- Abstract Heap

PrimVal# = Int# | Float# | True# | False# | None | Undefined
Object# = Type x Addr x ((Key -> Addr + Undefined) + ImTop + ImBot)
Val# = PrimVal# | Object# | <prim-callable># | Top_Val | Bot_Val

<prim-callable> = <prim-append># | <prim-+-int># | <prim-+-float># | <prim-*-int># | ...
\end{verbatim}

Explaining in detail how is the Abstract Domain for the state defined is out of the scope
of this chapter. A throughout explanation on the construction of the Abstract Domain can be
seen in Appendix~\ref{appendix-ai-theory}. We will dedicate the rest of this section
to show the motivation to define an Abstract Domain for states.

Consider the following piece of code:

\begin{pythoncode}
if s:
  a = 2
  b = a + 3
  c = [0.0, a, b]
else:
  a = 3
  b = a + 2
  c = [1, a, b]
\end{pythoncode}

In the example, we do not know the value of \pycode+s+, and therefore, we have no idea
which of the two branches of the \pycode+if+ statement will be executed. The solution that
Abstract Interpretation presents us is to run both branches separately, each with a copy
of the state of the program. Then, all we need to do is to find an
\textbf{over}approximation of the two new states. Fortunately, finding an
overapproximation of the states is what we built an Abstract Domain for. The
\textit{join} ($\cup^{\text{State}}$) operation of an Abstract Domain tells us the
smallest common overapproximation between the two states.

We know that the state at the end of the \enquote{then} branch is \verb|(G1, H1)|, and the
state at the end of the \enquote{else} branch is \verb|(G2, H2)|, where:

\begin{verbatim}
G1 := {'s'-> 0, 'a'-> 1: 'b'-> 2: 'c'-> 3}  G2 := {'s'-> 0, 'a'-> 1: 'b'-> 2: 'c'-> 3}
H1 := {                                     H2 := {
  0 -> Top,                                   0 -> Top,
  1 -> 2,                                     1 -> 3,
  2 -> 5,                                     2 -> 5,
  3 -> (List, 3, {                            3 -> (List, 3, {
    'size' -> 4,                                'size' -> 4,
    ('index', 0) -> 5,                          ('index', 0) -> 5,
    ('index', 1) -> 6,                          ('index', 1) -> 6,
    ('index', 2) -> 7,                          ('index', 2) -> 7,
  }),                                         }),
  4 -> 3,                                     4 -> 3,
  5 -> 0.0,                                   5 -> 1,
  6 -> 2,                                     6 -> 3,
  7 -> 5,                                     7 -> 5,
}                                           }
\end{verbatim}

The result of joining the two states is \verb+(Gnew, Hnew)+, where:

\begin{verbatim}
Gnew := {'s'-> 0, 'a'-> 1: 'b'-> 2: 'c'-> 3}
Hnew := {
  0 -> Top,
  1 -> Top_Int,
  2 -> 5,
  3 -> (List, 3, {
    'size' -> 4,
    ('index', 0) -> 5,
    ('index', 1) -> 6,
    ('index', 2) -> 7,
  }),
  4 -> 3,
  5 -> Top,
  6 -> Top_Int,
  7 -> 5,
}
\end{verbatim}

Now that we have defined our abstract state, we can define the abstract semantics.

\subsection{Semantics for the Abstract State}

Defining abstract semantics is quite straightforward. All we need to do is to modify
the concrete semantics to work with new values:

\begin{verbatim}
E#[expr] : Global# x Heap#
         -> Global#
          x Heap#
          x (Val# + (Object# x (string x Val#)) + Iden)

E#[Name(id, ctx)](G#, H#) :=
  match ctx in
    case Load  -> if G#(id) = Undefined
                  -- the variable `id` has not been defined then we "set" it in the global
                  -- scope and return `Top_Val`
                  then let ad := freeaddr(H#)
                        in (G#[id->ad], H#[ad->Top_Val], Top_Val)
                  else (G#, H#, G#(id))
    case Store -> (G, H, id)
    case Del   -> (G, H, id)

E#[Int(n)](G, H) := (G, H, n)

get_prim_op : Op x Val# x Val# -> Global x Heap -> Global x Heap x Val#

get_prim_op#(Add, v1, v2) :=
  match (type(v1), type(v2)) in
    case (Int, Int) -> \(G#, H#) -> <prim-+-int>#(v1, v2, G#, H#)
    case (Float, Float) -> \(G#, H#) -> <prim-+-float>#(v1, v2, G#, H#)
    case (Int, Bool) -> \(G#, H#)-> <prim-+-int>#(v1, Int(v2), G#, H#)
    case (Bool, Int) -> \(G#, H#)-> <prim-+-int>#(Int(v1), v2, G#, H#)
    case (Float, a) -> if a = Bool or a = Int
                       then \(G#, H#)-> <prim-+-float>#(v1, Float(v2), G#, H#)
                       else <prim-ret-top>#
    case (a, Float) -> if a = Bool or a = Int
                       then \(G#, H#)-> <prim-+-float>#(Float(v1), v2, G#, H#)
                       else <prim-ret-top>#
    case otherwise -> <prim-op-top>#

<prim-op-top># : Global# x Heap#
<prim-op-top>#(G#, H#) := (G#, H#, Top_Val)


S#[stmt] : Global# x Heap# -> Global# x Heap#

S#[Assign(var, val)](G#, H#) :=
  let (G1#, H1#, ass) := E[var](G#, H#)
      (G2#, H2#, rightval) := E[val](G1#, H1#)
      rval := if is_value#(rightval) then val else <Execution Halt>
   in
      match ass in
        case Iden -> (G2#[ass->rval], H2#)

        case ((t, addr, o): Object#, ('index', val: PrimVal#)) ->
          let setindex# := get_prim_set_index#(t)
          in setindex#(G2#, H2#, o, val, addr, rval)

        otherwise -> <Execution Halt>
\end{verbatim}

In the process of defining the new semantics, we can notice that the number of
\verb+<Execution Halt>+ expressions have reduced. Every \verb+<Execution Halt>+ that is
not the result of a parser error is caused by a type mismatch between values being
operated. An example of an execution halt caused by a type mismatch is \pycode|5 + None|
because no integer can be added to a \pycode|None|.

Executing a faulty piece of code now does not halt the interpreter:

\begin{pythoncode}
b = 2 + d
if b < 3:
  a = 2+3
else:
  a = 5-1+1
\end{pythoncode}

The state result of evaluating the function \verb|S#[b = 2 + d; a = b < 3]| is:

\begin{verbatim}
  G# := {
    d -> 0,
    b -> 1,
    a -> 2,
  }
  H# := {
    0 -> Top,
    1 -> Top,
    2 -> 5
  }
\end{verbatim}

\section{NdArrays}

The purpose of the specification is to be able to construct from it an Abstract
Interpreter. To test the Abstract Interpreter abilities to find bugs it should be able to
handle NumPy array (tensors). In this section, I extend the concrete semantics with NumPy
arrays.

The following are all the things to take into account when extending our specification to
handle a new type of \enquote{built-in} \pycode|Object| type:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Extend the types of \pycode|Object|s to handle NumPy arrays.

\begin{verbatim}
Type = List | Tuple | Module | NdArray
\end{verbatim}

  As an example, consider the numpy array \pycode|np.zeros((4, 3))|, it
  can be expressed as:

\begin{verbatim}
Object(NdArray,
 0xanumber,
 -- The shape of a NdArray is a tuple of integers
 { 'shape' -> Object(Tuple,
               0xothernum,
               { 'size' -> 2,
                 ('index', 0) -> 4,
                 ('index', 1) -> 3,
               }
              )
   ('index', 0) -> 0,
   ... -- all other indices, each one identified by an integer
 }
)
\end{verbatim}

  Note: Remember that an \pycode|Object| is a triple of the form
  \pycode|Type x Addr x (Key -> Addr + Undefined)|.
  Also, remember that the example above is faulty as the codomain of the
  function defined above is \pycode|Val| not \pycode|Addr| as it should
  be.
\item
  Extend primitive functions with NumPy's primitive functions. The
  NumPy's primitive functions implemented in the Abstract Interpreter
  are: \pycode|array|, \pycode|zeros|, \pycode|dot|, \pycode|ones|,
  \pycode|abs| (and all other functions that don't alter the shape of
  the tensor they take), \pycode|arange|, \pycode|size|, \pycode|ndim|,
  \pycode|astype|, and \pycode|T|.

\begin{verbatim}
<prim-callable> = ... (old operations) |
                  <prim-np-zeros> | <prim-np-dot> | <prim-np-abs> | ...
\end{verbatim}

  Note: The values stored inside a NumPy array are considered irrelevant
  in this work. The Value Analysis built in this work considers only the
  shape of tensors, as tensors can be huge and their contents do not
  often influence their shape. Therefore, it would be wasteful to give a
  detailed specification of the NumPy library primitives.

  Nonetheless, defining formally each one of the NumPy functions above is
  fairly straightforward. Although, the hardest part of a formal
  definition of NumPy arrays is detailing how \pycode|array| works. To
  define the function \pycode|<np-array>| one
  must consider the many input cases it can handle, and it can handle
  almost any Python object\footnote{The NumPy function \pycode|array|
    takes almost anything as an input. \pycode|array| tries to
    interpret its input as an array in any way it can. There is no
    formal definition of how the values are interpreted although its
    semantics can be extracted by looking at its C implementation:
    \url{https://stackoverflow.com/a/40380014}}.

  Once the \pycode|<np-array>| function is
  implemented all other functions are much simpler to define. As an
  example, the implementation of the function \pycode|size| is:

\begin{verbatim}
<prim-np-size>(val)(G, H) :=
   -- We know that `<prim-array>` always returns an NdArray
   let (G, H, (NdArray, addr, arr)) := <prim-array>(val)(G, H)
   -- We know that a NdArray has a special value called `shape`
       (Tuple, addrtup, tup) := arr('shape')
   in  tup('size')
\end{verbatim}
% \item
%   Extend the cases that \pycode|get_prim_op| handles to cover NumPy
%   arrays. All operations defined in NumPy handle broadcasting.
%   %{\todo{Explain what broadcasting is}}
%   For example:
%
% \begin{verbatim}
% get_prim_op(Add, v1, v2) :=
%   match (type(v1), type(v2)) in
%     ... -- old cases
%     case (NdArray, t1) ->
%       \(G, H)->
%         let (G1, H1, ndarr) := <prim-array>(v2)(G, H)
%         in  <prim-+-ndarray>(v1, ndarr, G1, H1)
%     case (t1, NdArray) ->
%       \(G, H)->
%         let (G1, H1, ndarr) := <prim-array>(v1)(G, H)
%         in  <prim-+-ndarray>(ndarr, v2, G1, H1)
%     case otherwise -> <Execution Halt>
% \end{verbatim}
\item
  The NumPy module holding all operations is defined:

\begin{verbatim}
<numpy-mod> := Object(Module,
 -1,  -- This value will be changed once it is imported
 { ('attr', 'array') -> <prim-array>,
   ('attr', 'dot')   -> <prim-dot>,
   ('attr', 'zeros') -> <prim-zeros>,
   ('attr', 'ones')  -> <prim-ones>,
   ...
 }
)
\end{verbatim}
\item
  And finally, \pycode|S[Import(name)]| is extended (now it handles
  a single library):

\begin{verbatim}
S[Import(name)](G, H) :=
  match name in
    ("numpy",) ->
      let (Module, arr, mod) := <numpy-mod>
          freeaddr := get_free_addr(H)
      in  (G['numpy'->freeaddr], H[freeaddr->(Module, freeaddr, mod)])
    ("numpy", alias) ->
      let (Module, arr, mod) := <numpy-mod>
          freeaddr := get_free_addr(H)
      in  (G[alias->freeaddr], H[freeaddr->(Module, freeaddr, mod)])

    otherwise -> <Execution Halt>
\end{verbatim}
\end{enumerate}


\section{Type Annotations}

Notice that we have not yet talked about the abstract semantics of \pycode|AnnAssign|.
The idea of type annotations is that they let us refine the value/type of a variable when
the Abstract Interpreter is unable to define a precise value.

An example of what annotations should be able to do is:

\begin{pythoncode}
from mypreciouslib import amatrix
from pytropos.hints.numpy import NdArray

mat: NdArray[1,12,6,7] = np.array(amatrix)
newmat = (mat + 12).reshape((12*6, -1))  # newmat has shape (12*6,7)
newmat = newmat.dot(np.ones((8, 21)))  # Error! Matrix multiplication, 7!=8
\end{pythoncode}

When one imports an arbitrary library like \pycode|mypreciouslib| it is
impossible to know what we may have imported so every variable imported
is a \verb|Top_Val|, i.e.~anything. By adding an annotation to
\pycode|mat|, we are telling the abstract interpreter that we know, and
are sure, of the shape of the NumPy array.

The semantics for \texttt{AnnAssign} are:

\begin{verbatim}
S[AnnAssign(var, hint, val)](G, H) :=
  let (G1, H1, evaluatedhint) := E[hint](G, H)
      (G2, H2, evaluatedhint) := E[hint](G1, H1)
      hintval := if isvalue#(evaluatedhint) then evaluatedhint else <Execution Halt>

   in S[Assign(var, val)](G1, H1)

  let (G1, H1, ass) := E[var](G, H)
      (G2, H2, evaledhint) := E[hint](G1, H1)
      (G3, H3, rightval) := E[val](G2, H2)
      compval := if is_value(rightval) then val else <Execution Halt>
      hintval := if isvalue#(evaledhint) then evaledhint else <Execution Halt>

      -- if `hintval` is more precise than `compval` we replace it
      rval := if hintval < compval then hintval else compval
   in
      ... -- Continue as in S[Assign(...)]
\end{verbatim}

Notice that we determine the \enquote{precision} of a hint with respect to the variable
with the comparison between values, the order \verb|Val#|!

Further details on the concrete and abstract semantics are given in Appendix~\ref{appendix-ai-theory}.
